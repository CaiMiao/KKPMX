# Cazoo - 2021-06-12
# This code is free to use, but I cannot be held responsible for damages that it may or may not cause.
#####################
from typing import List
import re
import os
import json
import copy   ## copy.deepcopy

import kkpmx_core as kklib
import kkpmx_utils as util

try:
	import nuthouse01_core as core
	import nuthouse01_pmx_parser as pmxlib
	import nuthouse01_pmx_struct as pmxstruct
	import _prune_unused_bones as bonelib
	import morph_scale
except ImportError as eee:
	print(eee.__class__.__name__, eee)
	print("ERROR: failed to import some of the necessary files, all my scripts must be together in the same folder!")
	print("...press ENTER to exit...")
	input()
	exit()
	core = pmxlib = pmxstruct = morph_scale = bonelib = None

#############
### :: (\w+)( +):= "_(\w+).png"   --> \1\2= "\3"
t__Alpha     = "AlphaMask"
t__Another   = "AnotherRamp"
t__Color     = "ColorMask"
t__Detail    = "DetailMask"
t__Glass     = "GlassRamp"
t__HairGloss = "HairGloss"
t__Line      = "LineMask"
t__Liquid    = "liquid"
t__Main      = "MainTex"
t__MainCol   = "MainC"
t__NorMap    = "NormalMap"
t__NorMapDet = "NormalMapDetail"
t__NorMask   = "NormalMask"
t__overtex1  = "overtex1"
t__overtex2  = "overtex2"
t__overtex3  = "overtex3"

Color_1 = "Color"
Color_2 = "Color2"
Color_3 = "Color3"
Color_Tex1 = "overcolor1"
Color_Tex2 = "overcolor2"
Color_Tex3 = "overcolor3"
Color_Line     = "LineColor"
Color_Shadow   = "ShadowColor"
Color_Specular = "SpecularColor"

##########
## meta attributes
NAME     = "name"
BASE     = "base"
OPTIONS  = "options"
#---
OPT_ENG   = "use_english"
OPT_HAIR  = "process_hair"
OPT_IMG   = "generate_images"              ## Will not generate any pictures or throw if not found
OPT_CACHE = "ignore_hair_inheritance"
OPT_SKIP  = "skipJSON"
OPT_ERRS  = "throwAtEnd"               ## <todo>: Collect errors and throw at the end
#---
GROUP    = "group"    ### Determines the texture type to use. Will fallback to [shader] if missing.
TEXTURES = "textures" ### Maybe call it "used_textures"
INHERIT  = "inherit"  ### Shallow copy all attributes from the target block
META     = "meta"     ### Opens sub tree for meta attributes of the asset
TEMPLATE = "template" ### If true, the block will be considered used when determining unused blocks.
MODE     = "mode"     ### Secret option to override the "blend_mode" for DetailMask
#--- runtime only
IDX      = "index"
NO_FILES = "no_files"
PARENT   = "parentMat"
PARSED   = "parsed"
ROOT     = "root"
LEGACY   = "legacy"   ### If the asset was rendered in-game or uses Legacy processing
#---- added by plugin
SHADER     = "shader"
AVAILABLE  = "available"
MT_ENABLED = "enabled"
MT_RECEIVE = "receive"
MT_SHADOWS = "shadows"
MT_RENDER  = "render"
MT_TYPE    = "renType"
MT_PARENT  = "parent"
MT_SLOT    = "slot"
#---- Extras
ARGSTR    = "argStr"
t__Reuse  = "Reuse"
ALTNAME   = "altName"
PROCESS   = "Processed"


#############
helptext = """
This is the second of two main methods to make KK-Models look better.
- Note: Current/Working directory == same folder as the *.pmx file.
- Within the *.json file, this is abbreviated as "%PMX%".

It will parse a processed plugin file and apply colors and shaders, as well as combining textures.
It also sets the visibility on customized multi-part assets and adds the accessory slots into the comment.
-- Remarks: All texture adjustments work based on "Garbage in, Garbage out": The results are only as good as the sum of the sources.
-- -- Several issues can be fixed by making sure all colors are properly set and undesirable ColorMasks are removed.

This does require some preparations before it can be used:
[1] A *.json file generated by [(7) GenerateJsonFile]
-- Default looks for "#generateJSON.json" in the working directory
-- Otherwise asks for the path if not found
[2] A folder filled with extra textures exported from KK (can be done manually with the [MaterialEditor] mod)
-- The path will be read from the above *.json in "options" > "base" and defaults to "./extra".
-- Currently working / supported are:
-- -- MainTex
-- -- DetailMask
-- -- ColorMask
-- -- LineMask
-- -- AlphaMask (except on Clothes)
-- -- overtex1 (on body and eye)
-- -- overtex2 (on eye)
-- Not (yet) supported are:
-- -- on body: overtex2
-- -- on face: overtex1, overtex2, overtex3
-- -- NormalMap, NormalMask

Additional notes:
-- After generation, the *.json file can be edited to change some aspects (some colors, visibility, textures) without KK. Re-run this to apply changes.
-- Due to pre-generation, sometimes textures are used that do not exist (which will print a warning). Remove the item from the faulty material's template to clear the warning. Of course you can also just ignore it if you don't miss anything from the model.
-- To override a specific texture with an irregular name, just add the Texture Name directly into the Material (see #Customize.md).
-- Example: Add ["MainTex": "C:\\full\\path\\to\\texture.png",] (without brackets, and using the correct path) to set a specific Main Texture (for cases like using a cloth slot multiple times (otherwise they would reuse the first one), which requires manually adding it to [generateJSON] to begin with)

[Issues]:
- When using KKS, the face texture may contain blank space where the blush is supposed to be. For the time being, please merge the blush and face texture yourself in that case.

[Options] (for Automization):
- [apply]: bool -- True to not wait for results and write directly to model. Prompts if [None]

[Options] (manually):
- Use Texture Cache (default: Yes)Â´-- Reuse Textures that share the same generation parameters. If, for some reason, you do not want that it can be turned off with this. Other than the increased amount of pictures, this shouldn't behave any different (if it does, please tell me)
- Asks to skip pictures (default: No) -- You can skip regenerating the pictures if all files already exist as expected (otherwise it will list them as missing as usual)

[Output]: PMX file '[modelname]_props.pmx'
"""
DEBUG = util.DEBUG or False
TEST_EYES = False
TEST_BODY = False

## Todos: Root Path

#############

pathDetail = r'.\extra\#Apply_DetailMap.py'
pathColor  = r'.\extra\#Apply_ColorMap.py'
pathBOver1 = r'.\extra\#Apply_Body_overtex1.py'
pathOT_eye = r'.\extra\#Apply_overtex1__eyes.py'
pathLine   = r'.\extra\#Apply_LineMap.py'

suffix_Col   = "_pyCol"
suffix_Det   = "_pyDet"
suffix_Line  = "_pyLin"
suffix_HL    = "_pyHL"
suffix_OT1   = "_pyOT1"
suffix_OTEye = "_pyOTHL"
######
## State -- maybe change to { mat_name: state[of "miss", "no_action", "no_files", "ok" ]}
msgs = { 'miss': [], 'no_action': [], 'no_files': [], 'skipped': [], 'errors': [] }
msgsPre = "-- "
EMPTY_TEXTURE = "."
local_state = { }
state_info = "showinfo"
debug_file = "showinfoFile"
state_SKIP = "state_SKIP"
state_UNITY = "unity"
state_SKIN = "sharedskin"
state_ONLY = "BODY_OR_EYE"
state_MAPTEX = "mapMain"
def _verbose(): return local_state.get(state_info, True)
def _useImg():  return local_state.get(OPT_IMG, True)

DEBUG_RUN = False
THROWERROR = True

################

def parseMatComments(pmx, input_file_name: str, write_model = True, moreinfo = False, opt = {}):
	paths = os.path.split(input_file_name)
	root = paths[0]
	print("==== Start Parsing ====")
	print("-- [Working Directory]: " + root);
	
	path = os.path.join(root, "#generateJSON.json") #@todo_note "<< Default file name >>"
	local_state[state_info] = moreinfo or DEBUG
	local_state[debug_file] = (moreinfo or DEBUG) and util.FILEDEBUG
	local_state[ARGSTR] = {}
	#### Load JSON
	def callback(raw_data):
		# replace Shorthand
		raw_data = raw_data.replace("%PMX%", re.escape(root)) #@todo_note "<< explain %PMX% >>"
		raw_data = raw_data.replace("SpeclarHeight", "SpecularHeight")
		raw_data = raw_data.replace("shadowcolor", Color_Shadow)
		return raw_data
	data = util.load_json_file(path, callback)
	if not data: return ## User already knows the reason
	
	msgs = __parse_json_file(pmx, data, root)
	if msgs is None: msgs = ["<< error >>"]
	
	log_lines = ["== Enhanced Model Textures =="] + msgs
	
	### Trim all textures
	for (idx,tex) in enumerate(pmx.textures):
		if os.path.isabs(tex):
			pmx.textures[idx] = os.path.relpath(tex, root)
	
	if local_state.get(state_ONLY, False) or DEBUG_RUN: return
	
	if not write_model: set_clean_texture(pmx, input_file_name)
	
	if write_model:# and False:
		flag = opt.get("apply", None)
		if flag is None: flag = util.ask_yes_no("Apply changes")
		if flag:
			set_clean_texture(pmx, input_file_name)
			return kklib.end(pmx, input_file_name, "_props", log_lines)
		return input_file_name
	else: return kklib.end(None, input_file_name, "_props", log_lines)
parseMatComments.__doc__ = helptext


def __parse_json_file(pmx, data: dict, root: str):
	"""
	@param pmx [Pmx]
	@param data [dict] The parsed JSON object
	@param root [str] The root path of the pmx file
	"""
	verbose = _verbose()
	##### == Processing JSON Dict
	attrDict = { }
	base = data.get(BASE, None) #@todo_note "BASE can be used to provide a relative base path for texture references"
	local_state[BASE] = root
	
	data.setdefault(OPTIONS, {})
	options = {
		BASE: base, # @todo_add "BASE can be defined alone or inside OPTIONS"
		OPT_ENG: False, #@todo_note: "Using OPT_ENG, the display name (name_jp) in the editor must not match the filename segment"
		OPT_HAIR: False,
		OPT_SKIP: False, ### To skip align of Material Names to JSON Order
	}
	options.update(data[OPTIONS])
	if base is None: base = options[BASE] #@todo_add "Outside BASE has priority over the one in OPTIONS"
	#--- NAME
	name = data.get(NAME, None)
	if name and pmx.header.name_jp in ["Koikatu","koikatu","Koikatsu","koikatsu","",None]:
		pmx.header.name_jp = name
		pmx.header.name_en = name
	
	hair_tabu = []
	local_state[OPT_HAIR]  = {}
	TEST_BODY = TEST_EYES = False
	SECOND = False
	local_state[state_MAPTEX] = util.DictAppend(0)
	
	if util.is_auto() or DEBUG_RUN:
		local_state[OPT_CACHE] = True
		local_state[OPT_IMG]   = True
	else:
		TEST_BODY = util.ask_yes_no("Re-run Body only", "n")
		TEST_EYES = util.ask_yes_no("Re-run Eyes only", "n")
		local_state[state_ONLY] = TEST_BODY or TEST_EYES
		local_state[OPT_CACHE] = util.ask_yes_no("Enable Texture Cache", "y", extra="Reuse Textures that use the same parameters. [See above for more info] ")
		local_state[OPT_IMG]   = not util.ask_yes_no("Skip images", "n")
	
	print(local_state)
	
	def set_name(_mat, _attr): ## Pick out the correct name based on options
		_name = _mat.name_en if options[OPT_ENG] else _mat.name_jp
		_attr[NAME] = _name
		return _name
	
	for mat_name in data.keys():
		if mat_name in [NAME, BASE, OPTIONS]: continue
		mat_idx = util.find_mat(pmx, mat_name, False)
		if mat_idx == -1:
			if type(data[mat_name]) == dict:
				if data[mat_name].get("template",False): continue # @todo_note "if TEMPLATE is true, it does not count as 'no match'"
			msgs['miss'].append(msgsPre + mat_name)
			print("\nCould not find {}, skipping".format(mat_name))
			if TEST_BODY or (TEST_EYES and SECOND): break
			if TEST_EYES: SECOND = True;
			continue
		mat = pmx.materials[mat_idx]
		attr = data[mat_name]
		local_state[state_SKIP] = {}
		
		if verbose: print("\n==== Processing (ALL) " + mat.name_jp)
		if len(attr) == 0: continue ## Catches {},[],"" #@todo_add "<< silent ignore of empty elements >>"
		if (mat.name_jp.startswith("cf_m_eyeline_kage")): continue
		if not verbose: print("\n==== Processing " + mat.name_jp)
		set_name(mat, attr)
		if TEST_EYES and not mat.name_jp.startswith("cf_m_hitomi"): continue
		if TEST_BODY and not mat.name_jp.startswith("cf_m_body"): continue
		
		# Copy Type
		if type(attr) in [str, list]:
			isStr = type(attr) == type("")
			org = attr if isStr else attr[0] ## [0] bc list
			if org not in data:
				print("[!] Did not find '{}' to inherit attributes from".format(org))
				continue
			print("> Copy attributes from " + org)
			attr = data[org]
			if isStr: attr[NO_FILES] = True ## @todo_note "Inherit[A]: Reuse the files of [inherit]"
			elif NO_FILES in attr: del attr[NO_FILES] ## @todo_note "Inherit[B]: Reuse all but files"
			attr[PARENT] = org
		#if True:#PARSED not in attr:
		# Field: Inherit
		if INHERIT in attr: ## @todo_note "Inherit[C]: Extend [inherit] with own fields"
			org = attr[INHERIT]
			if org not in data:
				print("[!] Did not find '{}' to inherit attributes from".format(org))
				continue
			print("> Extends " + org)
			tmp = copy.deepcopy(data[org])
			tmp.update(attr)
			attr = tmp
		# Field: Render Type
		if GROUP not in attr:  #@todo_note "GROUP determines action"
			if SHADER in attr: #@todo_note "SHADER is fallback for GROUP"
				attr[GROUP] = shader_dict.get(attr[SHADER], attr[SHADER])
			else:
				print(f"Material has no '{GROUP}' attribute, using 'item' instead") #@todo_add[GROUP] "'item' is default for GROUP"
				attr[GROUP] = "item"
		# Field: Do not reprocess if cloning
		if TEXTURES in attr: #@todo_note "TEXTURES can be used to use default names based on KK & BASE"
			if base is None:
				print("[err] Cannot process default textures without base path") #@todo_add[BASE] "BASE is required when using TEXTURES"
				return
			base_mat = mat
			if NO_FILES in attr: base_mat = pmx.materials[util.find_mat(pmx, attr[PARENT])] #@todo_ref "<< Inherit[A] >>"
			name = set_name(base_mat, attr) ## @todo_ref "<< OPT_ENG >>"
			#<< Because multi-part assets share a common texture, the unique-fyed name must be reduced for them.
			name = re.sub(r"\*\d+","",name) #@todo_note "<< smt about '* not allowed in filename' >>"
			
			ignErrors = False
			attr[LEGACY] = True
			if util.readFromCommentRaw(mat.comment, "[:Processed:]", exists=True):
				attr[PROCESS] = ignErrors = True
				attr[LEGACY] = False
				mat.comment = util.deleteCommentRaw(mat.comment, "[:Processed:]")
				if verbose: print("Texture was already exported preprocessed, resetting Textures...")
				
				if texDict[t__Main] not in attr[TEXTURES]: attr[TEXTURES].append(texDict[t__Main])
				for t in ["t__Color", "t__Detail", "t__Alpha", "t__Line"]:
					tt = texDict[t]
					if tt in attr[TEXTURES]: attr[TEXTURES].remove(tt)
					if tt in attr: del attr[tt]
			
			
			## Transform supported textures into actual paths
			#print("TEXTURES:: " + str(attr[TEXTURES]))
			for tex in set(texDict.values()):
				#print(f" Check if {tex} is in TEXTURES")
				if tex not in attr[TEXTURES]:
					if tex in attr: ## Remove if not supported
						if attr[tex] != EMPTY_TEXTURE:
							print(f"> Discarded unsupported {tex}")
						del attr[tex]
					continue
				_tex = attr.get(tex, None)
				#print(f"> Check if {tex} is in attr: {_tex}")
				##-- Keep custom paths
				if _tex is not None:
					## EDIT: Main is not exported correctly so it does not work.....
					if tex == t__Main: _tex = EMPTY_TEXTURE
					if _tex != EMPTY_TEXTURE:
						_path = get_relative_path(texDict[tex], attr)
						print(f"Found {tex:10} override with value .\\{_path}");
						if os.path.exists(os.path.join(root, _path)): continue
						print(f">> {os.path.join(base, _path)}: Not found, ignoring it...")
				
				## @todo_note: "if 'MainTex' is used but does not exist in BASE, use the one registered in the PmxMaterial, if any"
				##-- This generates default paths for the supported textures
				attr[texDict[tex]] = os.path.join(base, name + texSuffix[tex])
				#print(f">> Generate: {attr[texDict[tex]]}")
				if tex == t__Main and base_mat.tex_idx > -1:
					tmp = texDict[tex]
					if not os.path.exists(attr[tmp]):
						attr[tmp] = os.path.join(root, pmx.textures[base_mat.tex_idx])
					#-- Record how often a given Texture is used, to avoid identical assets (with different colors) from overwriting each other
					#local_state[state_MAPTEX].addOrInit(attr[tmp], 0, lambda v: v+1)
					local_state[state_MAPTEX][attr[tmp]] += 1
			##[If a MainTexture is set regardless, then always support that usecase regardless of Shader]
			if t__Main not in attr and base_mat.tex_idx > -1:
				tmp = texDict[t__Main]
				attr[tmp] = os.path.join(root, pmx.textures[base_mat.tex_idx])
				local_state[state_MAPTEX][attr[tmp]] += 1
				
		# Field: Add hair flag and keep track of duplicates
		if (attr[GROUP] == "hair"):
			attr[OPT_HAIR] = options[OPT_HAIR] and (attr[INHERIT] not in hair_tabu)
			## Don't keep track if reuse is disabled
			if local_state[OPT_CACHE]: hair_tabu.append(attr[INHERIT])
		#---
		if verbose: print(">--> Found {} attributes to process".format(len(attr)))
		attr[ROOT] = root
		attr[PARSED] = True

		parseDict = {
			'cloth': parse_acc, 'acc': parse_acc, 'item': parse_acc,
			'body': parse_body, 'face': parse_face,
			'eye': parse_eye, 'hair': parse_hair, 'color': parse_color,
			'alpha': parse_alpha, 'ignore': parse_pass, 'glass': parse_glass,
			'main': parse_main, 'metal': parse_metal, 'hair2': parse_hair2,
			}
		try:
			if attr[GROUP] in parseDict: parseDict[attr[GROUP]](pmx, mat, attr);
			elif not DEBUG_RUN:
				msgs['no_action'].append(msgsPre + mat.name_jp + f" ({attr[GROUP]})")
				print(">--> [MissingAction]: " + msgs['no_action'][-1])
				else: exit()
				if util.is_prod():  parseDict["item"](pmx, mat, attr)
		except Exception as err:
			print("--- Error while processing this Material")
			for (k,v) in attr.items():
				print(f"[{k}: {v}")
			raise err
		if TEST_BODY: break
		if TEST_EYES and SECOND: break
		SECOND = True
		
		##--- Reset them here in a uniform way cause they cause weird reflections
		mat.specRGB = [0.0, 0.0, 0.0]
		mat.ambRGB  = [0.5, 0.5, 0.5]
		
		## Clear texture cache after every run when reuse is disabled
		if not local_state[OPT_CACHE]: local_state[ARGSTR] = {}
	#######
	### Display summary for quick glance that something did not work
	arr = []
	## Remove meta items
	for a in [msgsPre + s for s in [NAME,BASE,OPTIONS]]:
		try:
			msgs['miss'].remove(a)
		except: pass
	
	arrSeg = '\n' + msgsPre
	
	if len(msgs['miss']) > 0:      arr.append('\n'.join(["The following elements were not found:", '\n'.join(msgs['miss'])]))
	if len(msgs['no_action']) > 0: arr.append('\n'.join(["The following materials had no valid action:", "\n".join(msgs['no_action'])]))
	if len(msgs['skipped']) > 0:   arr.append(arrSeg.join(["These textures have been skipped due to invalid configuration:", arrSeg.join(msgs['skipped'])]))
	if len(msgs['no_files']) > 0:
		tmp = [msgsPre + os.path.relpath(tex, base) for tex in msgs['no_files']]
		arr.append('\n'.join(["Additionally, these textures failed to generate:", "\n".join(tmp)]))
		arr.append("- To fix the above, provide the missing base file or remove it from the 'textures' element of the material")
	if len(arr) > 0:                    print('\n'.join(["==========",'\n\n'.join(arr),"=========="]))
	else:                               print("\n")
	
	## Actually add arr to LogLines
	return ["=========="] + arr + ["=========="]

#################
#### Parsers ####
#################
## name_jp: str, name_en: str,
## diffRGB: List[float],
## specRGB: List[float],
## ambRGB: List[float],
## alpha: float, specpower: float,
## edgeRGB: List[float], edgealpha: float, edgesize: float,
## tex_idx: int,
## sph_idx: int, sph_mode: int, --> Disabled, Add, Multi, Sub Texture
## toon_idx: int, toon_mode: int, --> 0 or 1
## comment: str,
## faces_ct: int,
## flaglist: List[bool], --> 2-SIDE, G-SHAD, S-MAP, S-SHAD, use_edge, V-COLOR, [Point], [Line]

###---- DetailMask override with value 
#-- Extends cf_m_top_parkerlong.MECopy2#-417096 
# [Asked] .\extra\cf_m_top_parkerlong.MECopy1_DetailMask@2213826.png --> MissingFile
# [Exist] .\extra\cf_m_top_parkerlong_DetailMask@-417108.png


def parse_color(pmx, mat, attr, mode="color"):
	print(f":: Running '{mode}' parser")
	if Color_1 in attr:
		if mat.tex_idx != -1 and str(mat.diffRGB) != "[0.0, 0.0, 0.0]":
			#mat.comment += "\r\nOld Diffuse: " + str(mat.diffRGB) + " (by parser)"
			mat.comment = util.updateCommentRaw(mat.comment, "[Old Diffuse]:", str(mat.diffRGB) + " (because texture)")
			mat.diffRGB = [0,0,0]
		mat.ambRGB = attr.get(Color_1, [0,0,0])[:3]
	#	mat.ambRGB = attr.get(Color_Shadow, attr[Color_1])[:3]
	#elif Color_Shadow in attr:
	#	mat.ambRGB = attr[Color_Shadow][:3]
	process_common_attrs(pmx, mat, attr)

def parse_body(pmx, mat, attr):
	print(":: Running 'body' parser")
	### (sic): body has no t__Alpha
	# t__Detail, t__Line, t__liquid, t__Main, t__NorMap, t__NorMapDet, t__NorMask, t__overtex1+2+3
	# Color_Tex1+2+3,  Color_Shadow, Color_Specular
	# DetailNormalMapScale, nip, nip_specular, nipsize, notusetexspecular
	# rimpower, rimV, ShadowExtend, SpeclarHeight, SpecularPower, SpecularPowerNail, tex1mask
	###
	extend_colors(attr, [Color_Tex1, Color_Tex2, Color_Tex3, Color_Shadow, Color_Specular])
	attr.setdefault(t__overtex1, None)
	attr.setdefault(t__overtex2, None)
	#attr[Color_Shadow] = None ## @todo_note:: "custom Shadows make skin look weird"
	#del attr[Color_Shadow]
	process_common_attrs(pmx, mat, attr)
	if t__Detail in attr: #pass ## Load file, pass to [detail python]
		process_color_and_detail(pmx, mat, attr)
	if t__Line in attr:
		handle_body_line(pmx, attr)
		set_new_texture(pmx, mat, attr, [get_working_texture(attr), suffix_Line + ".png"])
	#if attr[t__NorMap]: pass
	#if attr[t__NorMask]: pass
	#if attr[t__NorMasDet]: pass
	if attr[t__overtex1]:
		handle_body_overtex1(pmx, attr)
		set_new_texture(pmx, mat, attr, [get_working_texture(attr), suffix_OT1 + ".png"])
	if attr[t__overtex2]: pass ##handle_body_overtex1(pmx, attr)
	
	arr = local_state.get(state_SKIN, [])
	arr.append(mat)
	local_state[state_SKIN] = arr

def parse_face(pmx, mat, attr):
	print(":: Running 'face' parser")
	###
	# t__Alpha, t__Detail, t__Line, t__liquid, t__Main, t__NorMap, t__NorMapDet, t__NorMask, t__overtex1+2+3
	# Color_Tex1+2+3, Color_Shadow, Color_Specular
	# DetailNormalMapScale, nip, nip_specular, nipsize, notusetexspecular, tex1mask
	# rimpower, rimV, ShadowExtend, SpeclarHeight, SpecularPower, SpecularPowerNail
	###
	extend_colors(attr, [Color_Tex1, Color_Tex2, Color_Tex3, Color_Shadow, Color_Specular])
	process_common_attrs(pmx, mat, attr)
	if mat.diffRGB == [0.5, 0.5, 0.5]: mat.diffRGB = [1,1,1]
	## [t__Line] ++ DetailNormalMapScale :: [SpecialEffects]
	#>> RGB-B ++ Alpha (0-200)
	
	## TODO Actually setting the skin.Diffuse to a skin color helps a lot in MMD
	
	remove_face_alpha(pmx, attr)
	
	if t__Detail in attr: #pass ## Load file, pass to [detail python]
		process_color_and_detail(pmx, mat, attr)
	if t__Line in attr and os.path.exists(attr[t__Line]):
		## By default it does not exist, so only do it if it actually does
		handle_body_line(pmx, attr)
		set_new_texture(pmx, mat, attr, [get_working_texture(attr), suffix_Line + ".png"])
	#if attr[t__NorMap]: pass
	#if attr[t__NorMask]: pass
	#if attr[t__NorMasDet]: pass
	#if attr[t__overtex1]:
	#	handle_body_overtex1(pmx, attr)
	#	set_new_texture(pmx, mat, attr, [get_working_texture(attr), suffix_OT1 + ".png"])
	#if attr[t__overtex2]: pass ##handle_body_overtex1(pmx, attr)
	
	#####--- Copy the attributes over to the body to keep them the same
	arr = local_state.get(state_SKIN, [])
	if len(arr) > 0:
		_mat = arr[0]
		## Colors
		_mat.diffRGB   = mat.diffRGB
		_mat.specRGB   = mat.specRGB
		_mat.ambRGB    = mat.ambRGB
		## Toon and Sphere
		_mat.toon_idx  = mat.toon_idx
		_mat.toon_mode = mat.toon_mode
		_mat.sph_idx   = mat.sph_idx
		_mat.sph_mode  = mat.sph_mode
		## Edge
		_mat.flaglist  = mat.flaglist
		_mat.edgesize  = mat.edgesize
		_mat.edgeRGB   = mat.edgeRGB
		_mat.edgealpha = mat.edgealpha
		##.... so basically all except texture, Comment, faces_ct, and name
		
	
########
	pass

def parse_acc(pmx, mat, attr): ## Shader actually ignores Alpha and always uses 255 (100% opaque)
	print(":: Running 'acc' parser")
	###
	# t__Another, t__Color, t__Detail, t__Line, t__Main, t__NorMap
	# Color_1, Color_2, Color_3, Color_Shadow
	# rimpower, rimV, ShadowExtend, SpeclarHeight
	###
	extend_colors(attr, [Color_1, Color_2, Color_3, Color_Shadow, Color_Specular])
	
	if attr[NAME].startswith("cf_m_tang") and Color_1 in attr:
		mat.diffRGB = attr[Color_1][:3]
		mat.ambRGB  = attr[Color_1][:3]
		## This color provides optimal shading in KK, but we don't want a shader for that.
		#if attr[Color_Shadow] == [0.75, 0.9586206, 1, 1]: del attr[Color_Shadow]
		## Actually, this is inside the mouth -- always ignore KK shader
		if Color_Shadow in attr:
			col = attr[Color_Shadow][:3]
			rgb = (int(col[0]*255), int(col[1]*255), int(col[2]*255))
			mat.comment = util.updateComment(mat.comment, "Backup Shadow:", rgb)
			del attr[Color_Shadow]
	
	process_common_attrs(pmx, mat, attr)
	if (mat.specRGB == [1,1,1]):
		mat.specRGB = [0,0,0]
	process_color_and_detail(pmx, mat, attr)
	if t__Line in attr: process_line_mask(pmx, mat, attr)
	
	#-- Some indication that only attributes have been applied ?
	
	########
	pass ###

def parse_eye(pmx, mat, attr): ## @open: rotation, offset, scale
	print(":: Running 'eye' parser")
	####
	## t__expression, t__Main, t__overtex1, t__overtex2
	## Color_Tex1+2, Color_Shadow, exppower, isHighLight, rotation
	####
	extend_colors(attr, [Color_Tex1, Color_Tex2, Color_Shadow], True)
	process_common_attrs(pmx, mat, attr)
	if t__overtex1 in attr or t__overtex2 in attr:
		handle_eye_highlight(pmx, attr)
		set_new_texture(pmx, mat, attr, [attr[t__Main], suffix_HL + ".png"])

def parse_hair(pmx, mat, attr): ## [HasTodo] @open: t__Color, t__Detail, t__HairGloss, Color2, Color3
	print(":: Running 'hair' parser")
	verbose = _verbose()
	###
	# t__Alpha, t__Another, t__Color, t__Detail, t__HairGloss, t__Main, t__NorMap
	# Color_1, Color_2, Color_3, Color_Line, Color_Shadow
	# rimpower, rimV, ShadowExtend, SpeclarHeight
	###
	extend_colors(attr, [Color_1, Color_2, Color_3, Color_Line, Color_Shadow])
	process_common_attrs(pmx, mat, attr)
	
	#--- TODO
	# When keeping the main Hair Color as [Diffuse, Specular], then faint Highlights are invisible (with own ToonShader)
	#-- Not so much when using the Color3 for all three
	# :: After some tests, it seems to work WAY BETTER (in PMXE at least) when adding TIPS to Diffuse & Specular, keeping MAIN in Ambient
	
	## This may notify users about a maybe-wrong color configuration for this asset -- 
	if attr[Color_1] == attr[Color_2] == attr[Color_3] == [1,1,1,1] and os.path.exists(attr.get(t__Main, "")):
		print("::-- Detected mono ColorMask on Hair piece with MainTex -- Ignoring ColorMask")
		if verbose: print("::-->> That way you can at least fix the colors manually either here or in KK")
		parse_hair2(pmx, mat, attr)
		return
		
	
	# OPT_HAIR says if this render is the first of its material to be rendered
	if attr[OPT_HAIR]:
		#calculate_reusable_textures(attr)
		process_color_and_detail(pmx, mat, attr)
	# otherwise load its final texture from local_state
	elif attr[INHERIT] in local_state[OPT_HAIR]:
		attr[t__Reuse] = local_state[OPT_HAIR][attr[INHERIT]]
		txt = f".\\{get_relative_path(attr[t__Reuse])}"
		if verbose: print(f"> Reusing texture(hair) of {attr[INHERIT]}: {txt}")
		else: print(f"> Reusing texture {txt}")
		set_new_texture(pmx, mat, attr, [attr[t__Reuse], ".png"])
		
	if Color_1 in attr:
		mat.diffRGB = attr[Color_1][:3]
		mat.specRGB = attr[Color_1][:3]
		if mat.ambRGB == [1,1,1]: mat.ambRGB = [0,0,0]

def parse_hair2(pmx, mat, attr): ## @open: t__Color, t__Detail, t__HairGloss, Color2, Color3 <<< Use this as "Make all hair the same color" kind of thing, req. img of Main Color
	print(":: Running 'hair2' parser")
	verbose = _verbose()
	###
	# t__Alpha, t__Another, t__Color, t__Detail, t__HairGloss, t__Main, t__NorMap
	# Color_1, Color_2, Color_3, Color_Line, Color_Shadow
	# rimpower, rimV, ShadowExtend, SpeclarHeight
	###
	extend_colors(attr, [Color_1, Color_2, Color_3, Color_Line, Color_Shadow])
	process_common_attrs(pmx, mat, attr)
	if t__Color in attr: del attr[t__Color]
	
	def replFN(elem, name):
		_path = os.path.split(elem)
		_exe = os.path.splitext(_path[1])
		return os.path.join(_path[0], _exe[0] + name + _exe[1])
	process_color_and_detail(pmx, mat, attr) ## Seems to be skipped if Reuse is active
	
	if not set_new_texture(pmx, mat, attr, [get_working_texture(attr), "@" + attr[META][MT_SLOT] + ".png"],copyIfMissing=True):
		if local_state[OPT_IMG]: util.throwIfDebug(DEBUG, "Uhh.... not supposed to happen I guess")
	
	if Color_1 in attr:
		mat.diffRGB = attr[Color_1][:3]
		mat.specRGB = attr[Color_1][:3]
		if mat.ambRGB == [1,1,1]: mat.ambRGB = [0,0,0]

def parse_alpha(pmx, mat, attr): ## @todo -- Acc Shader that respects Alpha in Colors
	print(":: Running 'alpha' parser")
	###
	# t__Alpha, t__Another, t__Color, t__Detail, t__Main, t__NorMap
	# Color_1, Color_2, Color_3, Color_Line, Color_Shadow
	# rimpower, rimV, ShadowExtend, SpeclarHeight
	###
	#[main_clothes_alpha]: t__Alpha, t__Another, t__Detail, t__Line, t__Main, t__NorMap
	#  Color_Shadow, Color_Specular
	#  alpha==SeeThrough-ness (1..0, inate 90%), alpha_a, alpha_b, AlphaMaskuv
	###
	extend_colors(attr, [Color_1, Color_2, Color_3, Color_Line, Color_Shadow])
	process_common_attrs(pmx, mat, attr)
	process_color_and_detail(pmx, mat, attr)
	if t__Line in attr: process_line_mask(pmx, mat, attr)
	
	#util.__typePrinter_Dict(attr)
	
	if "alpha" in attr:
		if Color_1 in attr:
			mat.diffRGB = attr[Color_1][:3]
		mat.alpha = attr["alpha"]
		if mat.alpha == 0: 
			mat.comment = util.updateCommentRaw(mat.comment, "[:OpacityInfo:]", "This material was exported with an explicit opacity of 0. Verify if this was intended.")
			#util.disable_mat(mat)
	else:
		if Color_1 in attr:
			mat.diffRGB = attr[Color_1][:3]
			mat.alpha = attr[Color_1][3]
		## main_alpha just means it can have alpha, not that it must have it
		else: mat.alpha = 0.9
	print(f"--- With alpha = {attr.get('alpha', mat.alpha)}")

def parse_glass(pmx, mat, attr):
	mat.specpower = 1.0
	parse_color(pmx, mat, attr, "glass")

def parse_main(pmx, mat, attr):
	print(":: Running 'main' parser")
	###
	# t__Main, Color
	###
	extend_colors(attr, [Color_1, Color_2, Color_3, Color_Shadow, Color_Specular])
	process_common_attrs(pmx, mat, attr)

def parse_metal(pmx, mat, attr): ## @todo
	parse_color(pmx, mat, attr, "metal")

def parse_pass(pmx, mat, attr): pass
####################
#### Processing ####
####################

#### Toon
def draw_toon_shader(pmx, input_file_name):
	"""
	Allows to manually generate a toon shader. [pmx] is only needed for the storage path & not loaded
	Asks for a RGB color in the form '123,123,123'
	Why would you need that?
	Because usually the card uses precolored textures which means the [Color] attributes are ignored
	and thus contain mismatched values.
	"""
	root = os.path.split(input_file_name)[0]
	pathDir = os.path.join(root, "toon")
	while(True):
		rgb = util.get_list_of_numbers(3, [0,255], "Please state the desired RGB value (Range 0-255)")
		name = f"toon__{rgb[0]}_{rgb[1]}_{rgb[2]}.png"
		print(f"> MatColor: [{rgb[0]/255}  {rgb[1]/255}  {rgb[2]/255}]")
		pathFile = os.path.join(pathDir, name)
		if not os.path.exists(pathFile):
			if not os.path.exists(pathDir): os.mkdir(pathDir)
			args = ["", rgb, pathFile]
			script__draw_toon_shader(args)
		print(f"Drew {pathFile}")
		if not util.ask_yes_no("Do another",'y'): return

def script__draw_toon_shader(args):
	import numpy as np
	import cv2
	### https://github.com/jerryhouuu/Draw-Gradient-Alpha-Rectangle-using-openCV
	def draw_gradient_alpha_rectangle(frame, BGR_Channel, rect_pos=None, rotate=None):
		"""
		frame: The image to draw in :: np.zeros((300, 300, 3), np.uint8) ++ [:,:,:] = 255
		BGR_Channel: The target color, as tuple(B, G, R) ##(R, G, B) ?
		rect_pos: The area to draw a gradient into.
		rotate (white to color): 0 (L-R), 1(Upwards), 2(R-L), 3(Downwards)
		"""
		if rect_pos is None: rect_pos = ((0,0), (frame.shape[0], frame.shape[1]))
		if rotate is None: rotate = 3
		(xMin, yMin), (xMax, yMax) = rect_pos
		color = np.array(BGR_Channel, np.uint8)[np.newaxis, :]
		mask1 = np.rot90(np.repeat(np.tile(np.linspace(1, 0, (rect_pos[1][1]-rect_pos[0][1])), ((rect_pos[1][0]-rect_pos[0][0]), 1))[:, :, np.newaxis], 3, axis=2), rotate) 
		frame[yMin:yMax, xMin:xMax, :] = mask1 * frame[yMin:yMax, xMin:xMax, :] + (1-mask1) * color
		return frame#42, 175, 121
	frame = np.zeros((64, 64, 3), np.uint8)
	## options
	BGR = True
	gradient = 0
	####
	if BGR: color = list(reversed(args[1]))
	else: args[1]
	if gradient == 0: frame[:,:,:] = 255
	else:
		frame[:,:,0] = color[0]
		frame[:,:,1] = color[1]
		frame[:,:,2] = color[2]
		def adjust(c,i): c[i]= min(c[i] * 0.75,255)
		adjust(color,0); adjust(color,1); adjust(color,2)
	if gradient == 2: ### [:,32,*] = vertical
		frame[32:,:,0] = color[0]
		frame[32:,:,1] = color[1]
		frame[32:,:,2] = color[2]
		#frame[:2,:,:] = 255
	else: frame = draw_gradient_alpha_rectangle(frame, tuple(color), ((0,32), (64,64)))
	
	path = args[2]
	ext = os.path.splitext(path)[1]
	is_success, im_buf_arr = cv2.imencode("."+ext, frame)
	im_buf_arr.tofile(path)

def add_toon_shader(pmx, mat, attr):
	color = tuple(attr[Color_Shadow][:3])
	root = attr[ROOT]
	rgb = (int(color[0]*255), int(color[1]*255), int(color[2]*255))
	name = f"toon__{rgb[0]}_{rgb[1]}_{rgb[2]}.png"
	pathDir = os.path.join(root, "toon")
	pathFile = os.path.join(pathDir, name)
	if not os.path.exists(pathFile):
		if not os.path.exists(pathDir): os.mkdir(pathDir)
		args = ["", rgb, pathFile]
		script__draw_toon_shader(args)
	set_new_texture(pmx, mat, attr, [pathFile], tex_mode=tex_mode_toon)

def convert_color_for_RayMMD(pmx, input_file_name):
	"""
Reads out the #generateJSON.json and applies the "Color" attribute as Diffuse color for the asset (if it has any)
This may not always be implicit desireable as certain materials are colored by their textures, hence an extra function
Remark: This optimizes colors for RayMMD ToonMaterials; The Colors should already be fine for use with normal materials.
-- That said, it will still look a bit better if you use a 'ray.x' configured for RayMMD-Toon, at least.

In specific:
- Any material with '_delta' will receive the same settings as the corresponding base material without.
- If a material called 'cf_m_eyeline_kage' exists in the JSON, then
-  - cf_m_face_00 and cf_m_body receive Diffuse & SpecularColor from this material.
-  - Depending on their order in the 'Material' tab, the later ones copy the 'Toon' texture of the first.
- For all other materials (incl. the above if 'cf_m_eyeline_kage' does not exist)
-  - Set DiffuseColor to the color found in the corresponding 'Color' parameter, or skip the material if not found.
-  - Set SpecularColor to the color found in the corresponding 'SpecularColor' parameter, or 'Color' if not found.

[Output]: PMX file '[modelname]_toon.pmx'
"""
	root = os.path.split(input_file_name)[0]
	path = os.path.join(root, "#generateJSON.json") #@todo_note "<< Default file name >>"
	#### Load JSON
	def callback(raw_data):
		# replace Shorthand
		raw_data = raw_data.replace("%PMX%", re.escape(root)) #@todo_note "<< explain %PMX% >>"
		#raw_data = raw_data.replace("%PMX%", root.replace(r'\\', r'\\\\'))
		raw_data = raw_data.replace("SpeclarHeight", "SpecularHeight")
		raw_data = raw_data.replace("shadowcolor", Color_Shadow)
		return raw_data
	data = util.load_json_file(path, callback)
	if not data: return None
	### RGB/HSV
	# Skin defaults:
	#   Regular: 255 230 223 \\ 14 12 100 <<< in Kage (cofnfirmed)
	#		>> 1 0.9054397 0.875
	#   Reds:    255 175 146 \\ 16 42 100
	#   Nip:     255 204 193 \\ 11 24 100
	#   Cheek:   255 178 178 \\  0 29 100 -- Alpha=63
	# Eye defaults
	#   White (bright): 238 235 232 \\  28 2  93
	#   White (shaded): 183 186 196 \\ 229 6  77
	#   Highlights:     255 255 255 \\   0 0 100 -- Alpha=65
	# Mouth defaults:
	#   Teeth:       0.9044118 x3
	###
	isENG = data.get("options", {}).get("use_english", False)
	skin = ["cf_m_face_00", "cf_m_body", "cm_m_body"]
	skinToon = None
	## Kage may not have an own render mesh, but it contains the skin color for some reason
	kage = data.get("cf_m_eyeline_kage", None)
	msg = ["", "<< start >>: Kage exists=" + str(kage is not None)]
	for mat in pmx.materials:
		if DEBUG: print(msg[0] + msg[1]);
		name = mat.name_en if isENG else mat.name_jp
		msg = [f"> Doing '{name}'", ""]
		name = re.sub(r"_delta", "", name) ##<< Remark: update to use OPT_ENG
		## body & face only contain overcolor1+2+3 anyway, which has nothing to do with skin color.
		if kage and name in skin and Color_1 in kage:
			msg[1] = " >> Is skin"
			mat.diffRGB = kage[Color_1][:3]
			mat.specRGB = kage[Color_1][:3]
			if skinToon is None: skinToon = (mat.toon_mode, mat.toon_idx)
			else: (mat.toon_mode, mat.toon_idx) = skinToon
			continue
		def _handler(_name):
			attr = data.get(_name, None)
			if not attr: return
			msg[1] = " >> Has attr"
			if not Color_1 in attr:
				if not INHERIT in attr: return
				msg[0] += "\n== " + attr[INHERIT]
				return _handler(attr[INHERIT])
			msg[1] = " >> Repl with Color"
			col = attr[Color_1][:3]
			mat.diffRGB = col
			if Color_Specular in attr:
				msg[1] += " + SpecularColor"
				mat.specRGB = attr[Color_Specular][:3]
				mat.specpower = attr[Color_Specular][3]
			else: mat.specRGB = col
		_handler(name)
	return kklib.end(pmx, input_file_name, "_raycast")

#### Regular


def process_common_attrs(pmx, mat, attr): ## @open: rimpower, rimV, Color_Shadow
	###
	# Color_Line, Color_Shadow, Color_Specular (figure out smt new)
	# Set: specRGB, specpower, ambRGB, edgesize, edgeRGB, edgealpha, alpha, flaglist
	###
	if Color_Line in attr:
		if attr[Color_Line] == [0,0,0,0]:
			mat.flaglist[4] = False
			mat.edgesize = 0
		mat.edgeRGB = attr[Color_Line][:3]
		mat.edgealpha = attr[Color_Line][3]
	#if Color_Specular in attr:  mat.specRGB   = attr[Color_Specular][:3] :: Individual per group
	if "SpecularPower" in attr: mat.specpower = attr["SpecularPower"]
	if "LineWidthS" in attr:    mat.edgesize  = attr["LineWidthS"]
	
	
	if Color_Shadow in attr:# and attr[GROUP] not in ["hair"]:
		# smt smt only if not already set
		#if mat.ambRGB == [1,1,1]: mat.ambRGB    = attr[Color_Shadow][:3]
		#mat.diffRGB   = attr[Color_Shadow][:3]
		add_toon_shader(pmx, mat, attr)
		if mat.diffRGB == [1,1,1]:
			mat.diffRGB = [0.5, 0.5, 0.5]
			#mat.diffRGB   = [0,0,0]#attr[Color_Shadow][:3] smt only for black types
			#rgb = attr[Color_Shadow][:3]
	#	mat.comment += "Make toon_shader: " + str(attr[Color_Shadow]) ## Multiply each by 255 before
	if META in attr:
		meta = attr[META]
		#### Shadows
		## "On": == "one-sided", but 2-SIDE is default in PMX for all objects
		## "Two-sided": Makes single-sided objects two-sided
		## Maybe add "one-sided" instead #@todo:: find a reliable fix for that, or add a note
		shadow  = meta.get(MT_SHADOWS, "On")
		if shadow == "Shadows Only":
			mat.flaglist[4] = False #[use_edge]
			mat.flaglist[5] = True  #[V-COLOR]
		elif shadow == "Off": # no 2-side, G-SHAD, S-MAP, S-SHAD
			fl = mat.flaglist
			mat.flaglist = [ False, False, False, False, fl[4], fl[5], fl[6], fl[7] ]
		mat.flaglist[3] = 1 if meta.get(MT_RECEIVE, False) else 0
		#### If not enabled, make 100% transparent + remove edge
		flag = False ###--- The emblem is effectively disabled if it has no texture
		if attr[NAME].startswith("cf_m_emblem"): flag = mat.tex_idx == -1
		if not meta.get(MT_ENABLED, flag):
			mat.alpha = 0
			mat.flaglist[4] = False
			mat.comment = util.updateCommentRaw(mat.comment, "[:Disabled:]")
			local_state["disabled"] = True
		else: local_state["disabled"] = False
		#### Write TypeString into Comment
		if MT_TYPE in meta: mat.comment = util.updateComment(mat.comment, "MatType", meta[MT_TYPE])
		#### Add Slot into Comment (note: optimize this a bit later to also use updateComment but keep order)
		if MT_SLOT in meta:
			cmtNew = ["" if (not mat.comment or len(mat.comment) == 0) else mat.comment]
			def addComment(token, value, isRaw = False, _append=False):
				funcIN  = util.readFromCommentRaw if isRaw else util.readFromComment
				funcOUT = util.updateCommentRaw if isRaw else util.updateComment
				funcDEL = util.deleteCommentRaw if isRaw else util.deleteComment
				
				orgCmt = cmtNew[0]
				if "Disabled" in token:
					if funcIN(orgCmt, token, True):
						orgCmt = funcDEL(orgCmt, token)
						cmtNew.append(funcOUT("", "[:Disabled:]"))
					cmtNew[0] = orgCmt
					return
			
				if funcIN(orgCmt, token, True):
					value = re.sub(r"[\r\n]+", "", funcIN(orgCmt, token))
					orgCmt = funcDEL(orgCmt, token)
				if value is None: return
				cmtNew[0] = orgCmt
				cmtNew.append(funcOUT("", token, value.strip()))
				
			comment = meta[MT_SLOT]
			# [BodyTop]        --> p_cf_body_00, < clothes >
			# [p_cf_head_bone] --> ct_head
			# [cf_J_FaceUp_ty] --> ct_hairB, ct_hairF, ct_hairS
			if comment in ["BodyTop","p_cf_head_bone","cf_J_FaceUp_ty"]: comment = meta[MT_PARENT]
			if comment and len(comment) > 0: addComment("Slot", comment)
			addComment("CTASlot", None)
			
			par = meta[MT_PARENT]; ren = meta[MT_RENDER]
			### Add accessory slot as extra line
			if re.match("ca_slot\d+", par): addComment("AccId", re.match("ca_slot(\d+)", par)[1])
				### [bra]: render=o_bra_a, parent=ct_bra, slot=BodyTop \\ CTA: CTA_o_bra_a, ca_slot, a_n
				##if ren.startswith("CTA"):          comment += "\r\n[:CATId:] " + re.match("ca_slot(\d+)", par)[1]
				
			### Add Top sub slots as extra line
			if re.match("ct_top_parts_", par): addComment("TopId", par)
			### Give some navigation for primmats
			if attr[NAME].startswith("mf_m_primmaterial"): addComment("PrOrg", meta[MT_RENDER])
			
			addComment("MatType", None)
			addOld = ("[:MatType:] Hair" not in cmtNew[-1])
			
			if util.isDisabled(mat): addComment("[:Disabled:]", None, isRaw=True)
			addComment("[MatId]:", None, isRaw=True)
			
			if addOld: addComment("[Old Diffuse]:", None, isRaw=True)
			else:      cmtNew[0] = util.deleteCommentRaw(cmtNew[0], "[Old Diffuse]:")
			
			if not mat.comment or len(mat.comment) == 0:
				mat.comment = "\r\n".join(cmtNew[1:])
			else:##-- This at least ensures a consistent order
				mat.comment = "\r\n".join(cmtNew)
			mat.comment = re.sub(r"^\s*|\s*$", "", mat.comment)
			
			m = re.search(r"(0\.\d{5})\d*", mat.comment)
			if m is not None: mat.comment = re.sub(r"(0\.\d{5})\d*", f"{m[1]}", mat.comment)

	###--------- Extra Attributes
	_arr = []
	for a in _extraAttributes:
		if a in attr:
			_arr.append(a)
			mat.comment = util.updateComment(mat.comment, f"Extra[{a}]", attr[a], True)
	if len(_arr) > 0: print(f"> Adding ExtraAttributes {_arr}")

def process_color_and_detail(pmx, mat, attr):
	def replFN(elem, name): return os.path.join(os.path.split(elem)[0], name)
	def getFN(elem): return "" if elem is None else os.path.splitext(os.path.split(elem)[1])[0]
	executedOnce = False
	#if local_state.get("disabled", False): return
	
	if t__Color  in attr and attr[t__Color]  == EMPTY_TEXTURE: del attr[t__Color]
	if t__Detail in attr and attr[t__Detail] == EMPTY_TEXTURE: del attr[t__Detail]
	if t__Alpha  in attr and attr[t__Alpha]  == EMPTY_TEXTURE: del attr[t__Alpha]
	if t__Color not in attr and t__Detail not in attr:
		if t__Alpha not in attr: return
	
	detail_or_alpha = t__Detail in attr or t__Alpha in attr ## As both are run by the same script and have the same extension
	#print(">> detail_or_alpha is " + str(detail_or_alpha))
	#print(f"{attr.get(t__Color, 'noC')},{attr.get(t__Detail, 'noD')},{attr.get(t__Alpha, 'noA')}")
	
	## main_opaque has no color
	if t__Color in attr and Color_1 not in attr:
		#if t__Detail in attr: attr.setdefault(t__Main, attr[t__Detail]) else: attr.setdefault(t__Main, None)
		attr.setdefault(t__Main, "")
		if (getFN(attr[t__Main]).startswith("mf_m_primmaterial")):
			mat.flaglist[4] = False ## Disable Edge as well
			return
		if attr[t__Main] == "": attr[t__Main] = None
		print(f"> No colors found, skipping ColorMask")
	elif t__Color in attr:
		## Validate MainTex & void it if invalid
		attr.setdefault(t__Main, None)
		if attr[t__Main] and not os.path.exists(attr[t__Main]): attr[t__Main] = None
		## Check if there is no MainTex
		noMain = attr[t__Main] in [None,""] and META in attr
		#print("------ before handle_acc_color"); print(attr); print("-----")
		if noMain:
			ff = getFN(attr[t__Color])
			if (ff.startswith("mf_m_primmaterial")):
				## By default it does not exist, so delete it to avoid a standard warning
				if t__Detail in attr and not os.path.exists(attr[t__Detail]):
					del attr[t__Detail]
					detail_or_alpha = t__Alpha in attr and os.path.exists(attr[t__Alpha])
			attr[ALTNAME] = re.sub("_ColorMask","",ff) + "@" + attr[META][MT_PARENT] ##--- This prevents Detail Masks being reused across slots
		else:
			### Ignore mf_m_primmaterial if they have a MainTex
			if (getFN(attr[t__Main]).startswith("mf_m_primmaterial")):
				mat.flaglist[4] = False ## Disable Edge as well
				return
		handle_acc_color(pmx, attr)
		##-- Ensure we have a common tex key regardless which source the filename came from
		ff = attr[t__Color if attr[t__Main] is None else t__Main]
		if noMain or ALTNAME in attr: ff = replFN(ff, attr[ALTNAME])
		attr[t__MainCol] = re.sub(".png","",ff) + suffix_Col + ".png"
		##-- Remove a non-generated entry due to errors
		if attr[t__MainCol] and not os.path.exists(attr[t__MainCol]):
			if t__Reuse in attr: attr[t__MainCol] = attr[t__Reuse] ##<< replace if we reuse from a diff. slot
			else: del attr[t__MainCol]
		elif ARGSTR in attr: ## as 2nd condition since diff. slot will never do this tbh
			tmp = attr[ARGSTR]
			if tmp not in local_state[ARGSTR]: local_state[ARGSTR][tmp] = attr[t__MainCol]
		if t__Reuse in attr: print(f"> Reusing texture {get_relative_path(attr[t__Reuse])}")
		executedOnce = attr.get(t__MainCol, None) is not None
		executedOnce |= attr.get(t__Reuse, None) is not None ## Additional check

	##[!!!] -- Could get an issue if Reuse is active but no DetailMask (?)
	if attr.get(t__Main, None) == None and attr.get(t__MainCol, None) == None:
		msg = ""
		if t__Detail in attr and t__Alpha in attr: msg = "DetailMask nor AlphaMask"
		elif t__Detail in attr: msg = "DetailMask"
		elif t__Alpha in attr: msg = "AlphaMask"
		if len(msg) > 0: print(f"> No MainTex or ColorMask found, cannot apply " + msg)
	elif detail_or_alpha:
		handle_acc_detail(pmx, attr)
		executedOnce = True
	########
	## Textures can be skipped when scale was invalid
	skipColor    = local_state[state_SKIP].get(t__Color, False)
	skipDetail   = local_state[state_SKIP].get(t__Detail, False)
	
	if t__Reuse in attr:
		print(f"> Reusing texture {get_relative_path(attr[t__Reuse])}")
		set_new_texture(pmx, mat, attr, [attr[t__Reuse], ".png"])
	# if no t__Main, but used t__Color and t__Detail
	elif executedOnce and t__MainCol in attr: ## @todo_note
		saved = False
		if detail_or_alpha:
			saved = set_new_texture(pmx, mat, attr, [ff, suffix_Col + suffix_Det + ".png"], skipped=skipColor or skipDetail)
		if (not saved) or not detail_or_alpha:
			set_new_texture(pmx, mat, attr, [ff, suffix_Col + ".png"], skipped=skipColor)
	elif executedOnce and detail_or_alpha:
		set_new_texture(pmx, mat, attr, [attr[t__Main], suffix_Det + ".png"], skipped=skipDetail)
	
	canStoreInherit = (t__Color in attr and not skipColor)
	canStoreInherit = canStoreInherit or (t__Color not in attr and detail_or_alpha and not skipDetail)
	if attr.get(OPT_HAIR, False) and canStoreInherit:
		local_state[OPT_HAIR][attr[INHERIT]] = get_working_texture(attr)
	elif not canStoreInherit and not executedOnce:
		msgs["skipped"].append("MainTex of " + mat.name_jp)

def process_line_mask(pmx, mat, attr): handle_body_line(pmx, mat, attr)

def process_alpha_mask(pmx, mat, attr):
	## Currently part of Detail for Body, Face, Item
	##--- Alpha of Clothes will (in a later update) probably be done by [handle_overhang]
	pass ## Currently part of [Detail]

##############
#### Body ####
##############

def handle_body_detail(pmx, attr): ## @todo
	#attr[DetailMap_Scale] ## Mainly affects [Green]
	XXXX = attr["DetailNormalMapScale"] ## Render on top of ["nip"]
	XXXX = attr["notusetexspecular"]    ## Render on top of ["nip"]
	XXXX = attr["rimpower"]             ## 100% reduce "rimV" to Line
	XXXX = attr["rimV"]                 ## 0..100% of Specularity / Metal t__NorMask on Texture
	XXXX = attr["shadowExtend"]         ## Render on top of ["nip"]
	XXXX = attr["SpecularPower"]        ## Render on top of ["nip"]
	XXXX = attr["SpecularPowerNail"]    ## Render on top of ["nip"]
	XXXX = attr[Color_Specular]         ## 

def handle_body_overtex1(pmx, attr):
	#main = get_working_texture(attr)
	#mask = attr[t__overtex1]
	#col  = attr[Color_Tex1]
	#XXXX = attr["nip"]          # 1
	#spec = attr["nip_specular"] # 0.5 -- Strength of Layer X
	#size = attr["nipsize"]      # 0.6677417
	#mask = attr["tex1mask"]     # 1 -- Original vs. color overlay
	#-----------
	if NotFound(attr, t__overtex1): return
	
	arg1 = quote(get_working_texture(attr))
	arg2 = quote(attr[t__overtex1])
	
	legacyFlag = GROUP.startswith("KKU") or attr.get(LEGACY, False)
	
	js = { "color": attr[Color_Tex1], "nip":   attr["nip"], "size":  attr["nipsize"], "spec":  attr["nip_specular"], "legacy": legacyFlag }
	js[state_info] = local_state[debug_file]
	arg3 = quoteJson(js)
	call_img_scripts((pathBOver1, arg1, arg2, arg3), "body1", [3])

def handle_body_overtex2(pmx, attr): pass # @todo

def handle_body_line(pmx, attr):
	####
	# linetexon -- [Flag]: "body".t__Line.Green
	if NO_FILES in attr: return
	if NotFound(attr, t__Line): return
	arg1 = quote(get_working_texture(attr))
	arg2 = quote(attr[t__Line])
	js = { }
	js["mode"] = "overlay"
	js["linetexon"] = attr.get("linetexon",1) < 0  ## "body".tex__Line.Green
	js[state_info] = local_state[state_info]
	arg3 = quoteJson(js)
	call_img_scripts((pathLine, arg1, arg2, arg3), "line", [3])

##############
#### Face ####
##############

def handle_face_detail(pmx, attr): pass ## --> Body

def handle_face_effects(pmx, attr): ## @todo
	if NO_FILES in attr: return
	alpha = float(attr.get("DetailNormalMapScale", 1.0))
	alpha *= float(attr.get("ShadowExtend", 1.0))
	## apply [t__Line.Blue] * alpha onto [t__Main]
	##-- KKS: Put overtex2 under it
	##-- Both: But it above for 2nd blush texture (by cloning face mesh and use blush texture instead... or Bonelyfans ? [rename it then though])
	
	pass

def handle_eye_highlight(pmx, attr): ## Actually uses all three colors, so color in like body.overtex1
	if NO_FILES in attr: return
	arg1 = quote(attr[t__Main])
	js = { "highlight": attr.get("isHighLight", False) }
	# TODO: Move Left Eye left, and right eye right, respectively
	js["offset"] = attr.get("offset", "(0, 0)")
	js["scale"] = attr.get("scale", "(1, 1)")
	js[state_info] = local_state[debug_file] ## Always show full things here
	arg2 = quoteJson(js)
	#### offset(\d, \d), scale(\d,\d) overcolor1, overcolor2
	## TODO: Add option to generate Iris and Highlights separately
	if t__overtex1 in attr:
		arg3 = quote(attr[t__overtex1])
		col = (attr.get(Color_Tex1, [1,1,1,1]) * 255)
		js = { "color": col[:3], "alpha": col[3] }
		arg4 = quoteJson(js)
	else: arg3,arg4 = "","0"
	if t__overtex2 in attr:
		arg5 = quote(attr[t__overtex2])
		col = (attr.get(Color_Tex2, [1,1,1,1]) * 255)
		js = { "color": col[:3], "alpha": col[3] }
		arg6 = quoteJson(js)
	else: arg5,arg6 = "","0"
	call_img_scripts((pathOT_eye, arg1, arg2, arg3, arg4, arg5, arg6), "OT_eye", [2,4,6])

def handle_face_overtex2(pmx, attr): pass ## Do not merge, but try to add as extra ... material.... ._.

def remove_face_alpha(pmx, attr):
	if not _useImg(): return
	import cv2, numpy as np
	imgMain = attr[t__Main]
	imgBack = attr[t__Main][0:-4] + "_bk.png"
	if not os.path.exists(imgBack): util.copy_file(imgMain, imgBack)
	
	raw_image = None
	if util.is_ascii(imgMain): raw_image = cv2.imread(imgMain, cv2.IMREAD_UNCHANGED)
	if raw_image is None:
		try:
			stream = open(imgMain, "rb")
			bytes = bytearray(stream.read())
			numpyarray = np.asarray(bytes, dtype=np.uint8)
			raw_image = cv2.imdecode(numpyarray, cv2.IMREAD_UNCHANGED)
		except Exception as err2:
			print(err2)
	if raw_image is None:
		print("Unable to read Face Texture, please fix")
		return
	image = raw_image[:,:,:3]
	cv2.imwrite(imgMain, image)

##############
#### Item ####
##############

def handle_acc_color(pmx, attr): ### @FIX: Add the slot name to avoid things being overwritten if not different
	if NO_FILES in attr: return
	if NotFound(attr, t__Color): return
	
	main = attr.get(t__Main, None)
	if main and not os.path.exists(main): main = None
	attr[t__Main] = main
	attr.setdefault(Color_2, [0,0,0,1])
	attr.setdefault(Color_3, None)
	arg1 = '""' if attr[t__Main] == None else quote(attr[t__Main])
	arg2 = quote(attr[t__Color])
	arg3 = quoteColor(attr[Color_1])
	arg4 = '"[]"' if attr[Color_2] == None else quoteColor(attr[Color_2])
	arg5 = '"[]"' if attr[Color_3] == None else quoteColor(attr[Color_3])
	
	data = decorate_dimensions(attr, {}, t__Color)
	if data is None:
		local_state[state_SKIP][t__Color] = True
		return
	
	if attr[GROUP] == "hair": data["hair"] = True   # Set flag if Hair
	data[state_info]   = local_state[state_info]    # Verbosity flag
	data["saturation"] = attr.get("saturation", 1)  # Allows adjustments to Hair-Tip saturation
	arg6ArgStr = quoteJson(data) ## Since this is individual per slot, it prevents dupe detection
	add_if_found(attr, data, ALTNAME)             # Save with diff. name
	arg6 = quoteJson(data)
	
	## Build reuse id, apply [Alpha] in case it exists (since it should only be reused if same alpha)
	argStr = "color"+arg1+arg2+arg3+arg4+arg5+arg6ArgStr + attr.get(t__Alpha, "") ##[TODO] Redo-Reuse: Reuse ColorMask if same props
	
	attr[ARGSTR] = argStr
	tmp = local_state[ARGSTR].get(argStr, None)
	if (tmp): attr[t__Reuse] = tmp; return
	### If the Maintex is used multiple times, make sure the ColorTex is unique BUT stay idempotent
	# check if t__Main in state_MAPTEX > 1
	if local_state[state_MAPTEX][main] > 1:
		# Replace ALTNAME & overwrite arg6
		ff = os.path.splitext(os.path.split(main)[1])[0]
		attr[ALTNAME] = re.sub("@.+","",ff) + "@" + attr[META][MT_PARENT]
		add_if_found(attr, data, ALTNAME)
		orgArg6 = arg6
		arg6 = quoteJson(data)
	
	call_img_scripts((pathColor, arg1, arg2, arg3, arg4, arg5, arg6), "color", [6])

def handle_acc_detail(pmx, attr): ## Has @todo_add \\ @open: All the props affecting t__Detail
	if NO_FILES in attr: return
	# [t__Reuse] is set by ColorMask if happening -- Only do AlphaMask then
	#---[TODO]: Revamp Reuse system to allow partial reuse if only Color is the same
	#if t__Reuse in attr: return handle_acc_alpha(pmx, attr)
	if NotFound(attr, t__Detail): return handle_acc_alpha(pmx, attr)
	
	### Determine main texture & blend mode
	attr.setdefault(t__Main, None)
	mode = "overlay"
	if t__MainCol in attr:
		mode = "darken" ## Try: "mul" "diff" "nor"
		main = attr[t__MainCol]
	else:
		main = attr[t__Main]
		if attr[GROUP] == 'cloth': mode = "darken"
		elif attr[GROUP] in ['body','face']: mode = "screen"
	if MODE in attr: mode = attr[MODE] ## << Can be set in generateJSON if you want to.

	args = {}
	arg1 = quote(main) ## This is the altName without MainTex
	arg2 = quote(attr[t__Detail])
	
	data = decorate_dimensions(attr, {}, t__Detail)
	if data is None:
		local_state[state_SKIP][t__Detail] = True
		return
	
	data[state_info] = local_state[state_info]
	data["is_main"]  = attr[t__Main] is not None
	data["mode"]     = mode
	if "alpha_detail" in attr: data["alpha"] = attr["alpha_detail"] ## @todo_note: Affects Alpha-ness of DetailMask, default 64 / 256
	if attr[SHADER] == "body": data["is_body"] = True
	if attr[SHADER] == "face": data["is_face"] = True
	arg3 = quoteJson(data)
	arg4 = ""
	if NotFound(attr, t__Alpha, True) == False: arg4 = quote(attr[t__Alpha])
	
	## Ignore alpha for cloths
	if attr[GROUP] == "cloth":
		if len(arg4) > 0: print("> AlphaMask is not (yet) supported on 'cloth' type materials")
		arg4 = ""
	
	argStr = ""  ## This means we haven't done the ColorMask
	if ARGSTR not in attr: argStr = "detail"+arg1+arg2+arg3+arg4
	##				This means we have done the ColorMask (whose ARGSTR has t__Alpha already (but now should not anymore...))
	else: argStr = attr[ARGSTR] + "detail"+arg2+arg3 ## Also discard the MainCol Name -- covered by ColorMask as well
	attr[ARGSTR] = argStr
	tmp = local_state[ARGSTR].get(argStr, None)
	if (tmp): attr[t__Reuse] = tmp; return
	## If did *not* reuse this (but did reuse ColorMask), then delete the field to mark it as new texture
	if t__Reuse in attr: del attr[t__Reuse]
	call_img_scripts((pathDetail, arg1, arg2, arg3, arg4), "detail")

def handle_acc_alpha(pmx, attr): ## Has @todo_add \\ @open: All the props affecting t__Detail
	if NO_FILES in attr: return
	if t__Reuse in attr: return
	if NotFound(attr, t__Alpha, True): return
	
	### Determine main texture & blend mode
	attr.setdefault(t__Main, None)
	mode = "overlay"
	if t__MainCol in attr:
		main = attr[t__MainCol]
	elif attr[GROUP] == 'cloth':
		main = attr[t__Main]
	else: main = attr[t__Main]
	
	args = {}
	arg1 = quote(main)
	arg2 = ""
	
	data = { }
	data["details"] = _verbose() ## argv3 -> details
	data[state_info] = local_state[state_info]
	data["is_main"] = attr[t__Main] is not None ## argv4 -> mainSize
	data["mode"]    = mode                     ## argv5 -> mode
	if attr[SHADER] == "body": data["is_body"] = True ## argv6 -> is_body
	arg3 = quoteJson(data)
	arg4 = quote(attr[t__Alpha])
	try: call_img_scripts((pathDetail, arg1, arg2, arg3, arg4), "detail")
	except IOError as ioe: pass

############
#	X = attr[t__liquid]        ###	X = attr[t__Texture2]      ###	X = attr[t__Texture3]      ###	X = attr[Color_Liquid]     ##

#################
#### Utility ####
#################

def call_img_scripts(args, target, isJson = []):
	if not _useImg(): return
	if DEBUG or util.FILEDEBUG:
		##- Causes scripts to run in Main context which adds proper stacktrace
		try:
			if DEBUG and util.FILEDEBUG: print(' '.join(['"' + os.path.abspath(args[0]) + '"'] + list(args[1:])))
			os.system(' '.join(args))
		except Exception as eee:
			print(eee)
			if not DEBUG and util.FILEDEBUG: print(' '.join(['"' + os.path.abspath(args[0]) + '"'] + list(args[1:])))
			if THROWERROR: raise eee
	else:
		from unittest.mock import patch
		import runpy, sys
		try:
			target_dict = { 
				"color": "extra.#Apply_ColorMap",
				"detail": "extra.#Apply_DetailMap",
				"body1": "extra.#Apply_Body_overtex1",
				"OT_eye": "extra.#Apply_overtex1__eyes",
				"line": "extra.#Apply_LineMap",
			}
			if not target_dict.get(target): return
			with patch.object(sys, 'argv', [x.strip('"') for x in args]):
				runpy.run_module(target_dict.get(target))
		except Exception as eee: print(eee)

def ask_to_rename_extra(base):
	if not os.path.exists(base):
		print(f"{base} does not exist")
		return
	files = os.listdir(base)
	if not any(filter(lambda x: x.startswith("_Export"), files)): return
	if not util.ask_yes_no(f"Rename textures in [{base}]"): return
	re_cut = re.compile(r" ?\(Instance\)_?(\([-0-9]*\))?|_Export_[\d\-]+_")
	for fname in files:
		basename = os.path.join(base,fname)
		if not os.path.isfile(basename): continue
		newname = os.path.join(base, re_cut.sub("", fname))
		if basename == newname: continue
		if os.path.exists(newname):
			print(f"-- {os.path.relpath(newname, base)} already exists!")
			continue
		os.renames(basename, newname)

def decorate_dimensions(attr, data, name):
	_key = name + "_dim"
	if _key not in attr: return data
	dim = attr[_key] # Scale.X, Scale.Y, Offset.X, Offset.Y
	if (dim[0] <= 0.0 or dim[1] <= 0.0):
		print(f">> {name} will be ignored because Scale contains 0 or negative ({dim[0:2]})")
		return None
	
	scale  = [ dim[0], dim[1]]
	offset = [ dim[2], dim[3]]
	if str(scale)  != "[1.0, 1.0]": data["scale"]  = scale
	if str(offset) != "[0.0, 0.0]": data["offset"] = offset
	return data

def add_if_found(attr, data, name, attr_name=None): ## Add attr[attr_name ?? name] to data if it exists
	if not attr_name: attr_name = name
	val = attr.get(attr_name, None)
	if val not in ["", None]: data[name] = val

#def quote(value): return '"' + re.sub("\\", "\\\\", str(value)) + '"'
def quote(value): ## return '"' + str(value).strip('"').strip("'") + '"'
	tmp =  '"' + str(value).strip('"').strip("'") + '"'
	return tmp
def quoteColor(value):
	tmp = []
	for (i,c) in enumerate(value): tmp.append(int(c*255))
	return '"' + str(tmp).strip('"').strip("'") + '"'
def quoteJson(value):
	tmp = json.dumps(value)
	if local_state.get(debug_file, True): tmp = re.sub(r'"', r'\\"', tmp)
	return '"' + tmp + '"'

def extend_colors(attr, col_arr, dodefault = False):
	for col in col_arr:
		if col in attr:
			if dodefault: attr[col] = attr.get(col, [0,0,0])
			if attr[col] is None:   continue
			if len(attr[col]) < 3:  raise Exception("Warning: {} is too short!".format(col))
			if len(attr[col]) == 3: attr[col].append(1)

tex_mode_toon = "toon"
tex_mode_main = "main"
tex_mode_sphr = "sphere" ## [TODO] Redo-Reuse: Store Color & Detail reuse separately
## [TODO]: Store Textures instead of [ID _pyCol... @ SLOT] as smt that is derived from Name + Slot + position (to allow reusing Materials for Debugging >.<)
def set_new_texture(pmx, mat, attr, tex_names: list, tex_mode=tex_mode_main, skipped=False, copyIfMissing=False):
	"""
	:param  mat [PmxMaterial]  
	:param  attr [Dict]        
	:param  tex_names [Dict]   
	:param  tex_mode [enum]    "toon", "main", or "sphere"
	"""
	isToonMode = tex_mode == tex_mode_toon
	isSphereMode = tex_mode == tex_mode_sphr
	# [attr]: So that one can use "get_working_texture" but must not
	if tex_mode != tex_mode_main: tex_name = tex_names[0]
	#else:  tex_name = os.path.splitext(tex_names[0])[0] + tex_names[1]
	else:  tex_name = re.sub(".png", "", tex_names[0]) + tex_names[1] # Not splitext bc Names could have '.'
	
	if skipped:
		msgs["skipped"].append(tex_name)
		return False
	if not os.path.exists(tex_name):
		## Note: When doing [NO IMG], this collects all intermediate steps
		# e.g. one for _pyDet, _pyLin, _pyOT1 -- But Textures are still inside
		if not copyIfMissing:
			msgs["no_files"].append(tex_name)
			return False
		util.copy_file(tex_names[0], tex_name)
	if tex_name in pmx.textures:
		tex_idx = pmx.textures.index(tex_name)
	else:
		tex_idx = len(pmx.textures)
		pmx.textures.append(tex_name)
	if isToonMode:
		mat.toon_idx = tex_idx
		mat.toon_mode = 0
	elif isSphereMode:
		mat.sph_idx = tex_idx
		mat.sph_mode = 1
	else:
		mat.tex_idx = tex_idx
		attr[t__MainCol] = tex_name
		if ARGSTR in attr:
			tmp = attr[ARGSTR]
			if tmp not in local_state[ARGSTR]: local_state[ARGSTR][tmp] = tex_name
	return True

def get_working_texture(attr):
	if t__MainCol in attr:
		if attr[t__MainCol] is not None:
			return attr[t__MainCol]
	if t__Main in attr:
		if attr[t__Main] is not None:
			return attr[t__Main]
	msg = "Could not find working main texture!! Try only using ASCII in the directory paths!" ## Happens in NoImgMode for mayuge, nose, eyeline
	if not _useImg(): print(msg)
	else: raise Exception(msg)

def NotFound(attr, name, optional=False): ## Returns true if not found
	if name not in attr: return True
	if not os.path.exists(attr[name]):
		tmp = os.path.join(attr[ROOT], attr[name])
		if not os.path.exists(tmp):
			if name == t__overtex1:
				tmp2 = tmp + ".png"
				if os.path.exists(tmp2): os.renames(tmp2, tmp)
		if os.path.exists(tmp):
			attr[name] = tmp;
			return False
		if optional: return True
		print(f">--> [MissingFile({name})]: {get_relative_path(attr[name])}")
		return True
	return False

def get_relative_path(path, attr=None):
	base = local_state[BASE]
	if attr: path = attr.get(path, EMPTY_TEXTURE)
	return os.path.relpath(path, base)

def set_clean_texture(pmx, input_file_name):
	from kkpmx_utils import get_unique_name
	print("--- [Sorting Textures]")
	print("Read: Material -> TexID  -- if first occurence >> ::[Cleanup] --> TexName")
	basePath = os.path.split(input_file_name)[0]
	texPath = os.path.join(basePath, "tex") ## Destination folder
	if not os.path.exists(texPath): os.mkdir(texPath)
	nameMap = {
		"cf_m_body"         : "body",
		"cf_m_face_00"      : "face",
		"cf_m_mayuge_00"    : "head_eyebrows",
		"cf_m_noseline_00"  : "head_nose",
		"cf_m_tooth"        : "head_teeth",
		"cf_m_tooth_1"      : "head_teeth2",
		"cf_m_eyeline_00_up": "head_eyeline_up",
		"cf_m_eyeline_kage" : "head_eyeline_up2",
		"cf_m_eyeline_down" : "head_eyeline_down",
		"cf_m_sirome_00"    : "head_eye_white",
		"cf_m_hitomi_00"    : "head_eye_l",
		"cf_m_hitomi_00_1"  : "head_eye_r",
		"cf_m_tang"         : "head_tongue",
	}
	texTabu = [None, -1]
	imgTabu = []
	matTabu = []
	
	#-- Make sure we always have unique Materials
	for mat in pmx.materials: mat.name_jp = get_unique_name(mat.name_jp, matTabu, isFile=False)
	pad = max([len(mat.name_jp) for mat in pmx.materials]) + len(" --> '000'")
	try:
		for mat in pmx.materials:
			texIdx = mat.tex_idx
			#- Filter out invalid and disabled, and only do it once
			if texIdx in texTabu or util.isDisabled(mat):
				print(f"{mat.name_jp} --> '{texIdx}'")
				continue
			## TODO: Call 'eye_l' = 'eye' if both have same texture
			texTabu.append(texIdx)
			#---
			tex = pmx.textures[texIdx]
			msg = f"{mat.name_jp} --> '{texIdx}'"
			myPad = " " * (pad - len(msg))
			print(msg + myPad + f"::[Cleanup] --> '{tex}'")
			oldFile = os.path.join(basePath, tex)
			if not os.path.exists(oldFile):
				failed = True
				if tex.startswith("cf_m_tooth_("):
					tex = "cf_m_tooth.png"; tmp = oldFile
					oldFile = os.path.join(basePath, tex)
					failed = not os.path.exists(oldFile)
					if failed: oldFile = tmp
				if failed:
					print(f"{mat.name_jp} has non-existing Texture '{oldFile}'; skipping...")
					del texTabu[texIdx] ## remove again so that you see the error for all faulty materials
					continue
			
			name = re.sub(r"[\*: ]+", "_", mat.name_jp)
			if name in nameMap: token = nameMap[name]
			else:
				token = util.readFromComment(mat.comment, 'AccId')
				if token is None: token = util.readFromComment(mat.comment, 'Slot')
				else: token = "slot" + token
			if token: name = token + '@' + name
			
			##--- If the file already existed as renamed, accept that
			texFile = os.path.join(texPath, name + ".png")
			texFile = get_unique_name(texFile, imgTabu, isFile=True)
			
			try:
				util.copy_file(oldFile, texFile)
			except Exception as ex:
				if not os.path.exists(texFile): raise ## Ignore errors if the file already exists
			pmx.textures[texIdx] = os.path.relpath(texFile, basePath)
			
			##-- Check for AlphaMask
			m = re.match(r"^(.+?)(?:_py[A-Za-z1-9]+)*\.png$", tex)
			if (m):
				texBase = m[1] + ".alphaCut.png"
				alphaPath = os.path.join(basePath, texBase)
				if os.path.exists(alphaPath):
					texAlpha = os.path.join(texPath, name + "@alpha.png")
					try:
						util.copy_file(alphaPath, texAlpha)
					except Exception as ex:
						if not os.path.exists(texAlpha): raise ## Ignore errors if the file already exists
					##-- Replace texture with alphaCut unless its body / bra
					if token and not token in ["body", "ct_bra"]:
						pmx.textures[texIdx] = os.path.relpath(texAlpha, basePath)
			
	except Exception as ex:
		print(ex)
		return
	util.move_unused_to_folder(pmx, input_file_name)
	

##############
## Mappings ##
##############
texDict = {
	"t__Alpha"     : "AlphaMask",
	"t__Another"   : "AnotherRamp",
	"t__Color"     : "ColorMask",
	"t__Detail"    : "DetailMask",
	"t__Glass"     : "GlassRamp",
	"t__HairGloss" : "HairGloss",
	"t__Line"      : "LineMask",
	"t__Liquid"    : "liquid",
	"t__Main"      : "MainTex",
	"t__NorMap"    : "NormalMap",
	"t__NorMapDet" : "NormalMapDetail",
	"t__NorMask"   : "NormalMask",
	"t__Overtex1"  : "overtex1",
	"t__overtex1"  : "overtex1",
	"t__Overtex2"  : "overtex2",
	"t__overtex2"  : "overtex2",
	"t__Overtex3"  : "overtex3",
	"t__overtex3"  : "overtex3",
}

texSuffix = { ### :: (\w+)( +):= ("_(\w+).png") --> '    "\1":\2\3,'
    "t__Alpha":     "_AlphaMask.png",
    "t__Another":   "_AnotherRamp.png",
    "t__Color":     "_ColorMask.png",
    "t__Detail":    "_DetailMask.png",
    "t__Glass":     "_GlassRamp.png",
    "t__HairGloss": "_HairGloss.png",
    "t__Line":      "_LineMask.png",
    "t__Main":      "_MainTex.png",
    "t__NorMap":    "_NormalMap.png",
    "t__NorMapDet": "_NormalMapDetail.png",
    "t__NorMask":   "_NormalMask.png",
    "t__Overtex1":  "_overtex1.png",
    "t__overtex1":  "_overtex1.png",
    "t__Overtex2":  "_overtex2.png",
    "t__Overtex3":  "_overtex3.png",
}
for (k,v) in copy.deepcopy(texDict).items():
	texDict[v] = texDict[k]
	if k in texSuffix:
		texSuffix[v] = texSuffix[k]

shader_dict = {
	### Ignore
	"toon_textureanimation": "ignore", ## gageye
	"shadowcast": "ignore",
	"Bonelyfans": "ignore",
	"mnpb": "ignore",          ##[KK] WhiteOff \\ cf_m_mnpb
	"Standard": "color",       ## -- Too much going on, just do colors for now.
	#:: [DstBlend]: if 1, All but [Glossiness] is transparent
	# t__Glass, t__Main, t__NorMap ++ Color, Color4, ColorInverse, ColorSort, RimPower
	"toon_glasses_lod0": "glass", ##[KK] .... \\  cf_m_namida_00, c_m_gomu
	### Small
	"toon_eyew_lod0": "color", ##[KK] t__Main ++ Color, shadowcolor \\ mayuge, eyeline, kage, sirome
	"main_eyew": "color",      ##[KKS] for mayuge, eyeline
	"toon_eye_lod0": "eye",    ##[KK] t__Main, t__expression, t__overtex1, t__overtex2 ++ exppower, isHighLight, rotation // hitomi
	"toon_nose_lod0": "color", ##[KK] t__Main ++ Color
	"main_nose": "color",      ##[KKS] for nose
	"main_emblem": "color",    ##2450 t__Main ++ shadowcolor
	"main_color": "color",     ##2000 Color
	#"main_item": "item",      ##[KK] \\ tongue
	#"main_emblem_clothes": "color", ## t__Alpha, t__Main, Color, alphamaskuv ## Unused
	#########
	## "main_skin": --> "face","body" are special case and hardcoded as such.
	#	"main_skin": "body", ## cm_m_dankon, cm_m_dan_f
	"main_skin": "item", ## t__Alpha, t__Detail, t__Line, t__Liquid, t__Main, t__NorMap, t__NorMapDet, t__NorMask, t__overtex1+2+3, t__Texture2+3
	#:++ overcolor1+2+3, Col_Shadow, Col_Spec :: alpha_a+b, DetailNormalMapScale, linetexon, nip, nip_specular, nipsize, notusetexspecular, rimpower, rimV, SE, SH, SP, SPN, tex1mask
	
	# 			t__Another, t__Color,	t__Detail, t__Line, 		t__Main, t__NorMap
	"main_item": "item",              ##2450[KK,?_?] AnotherRampFull, DetailBLineG, DetailRLineR, LineWidthS, NUTS RP RV SE SEA SH SP
	"main_item_studio": "item",       ##2450[KK,?_?] ++ Add [z__EmissionPower] \\ Add PatternMask things
	"main_item_studio_alpha": "alpha", ##3000[KK,?_?] ++ Add [alpha, z__ambientshadowOFF, z__EmissionPower], Remove [LineWidthS] \\ Add PatternMask things
	#:KK: PatternMask1+2+3 \\ Color 1_2,2,2_2,3,3_2, Patternuv1+3+4 \\ pattern(clamp,rotator)1+2+3
	"main_item_emission": "item",     ##2450[KK,?_?] ++ z__AnimationMask \\ z__EmissionPower // Remove [SH SP]
	#:KK: z__AnimationMask, t__Another, t__Color, t__Detail, t__Line, t__Main, t__NorMap
	#>	\\ Color+2+3, Col_Shadow, AnotherRampFull, DetailBLineG, DetailRLineR, z__EmissionPower, LineWidthS, NUTS RP RV SE SEA, z__UPanner, z__VPanner
	
	# t__Alpha, t__Another, 			t__Detail, t__Line, t__liquid, t__Main, t__NorMap, 
	"main_opaque": "cloth",	##2450 t__Alpha, t__Another, t__Detail, t__Line, t__Liquid, t__Main, t__NorMap, t__Texture2+3 ++ DetailBLineG, DetailRLineR, NUTS RP RV SE SEA SH SP SPN
	"main_opaque2": "cloth", #--[^] z__AlphaMaskuv
	"main_opaque_low": "cloth", # ??
	"main_alpha": "alpha",	##3040 t__Alpha, t__Another, t__Detail, t__Liquid, t__Main, t__NorMap, t__Texture2+3
	# ++ Col_Shadow, Col_Spec :: DetailBLineG, outline, rimpower, rimV, SE, SP
	
	# t__Alpha, t__Another, t__Color, t__Detail, t__HairGloss, t__Main, t__NorMap
	"main_hair": "hair",       ##2000[KK,?_?] ++ Color, Color2, Color3, LineColor, ShadowColor, rimpower, rimV, ShadowExtend [KK]+ SpeclarHeight
	"main_hair_front": "hair", ##3040[KK,?_?] ++ [^] + SpecularHeight
	"KKUTShair": "hair",
	"KKUTSalpha": "item",
	"skin": "item",
	
	# t__Color, t__Detail, t__Line, t__Main, t__NorMap
	"main_texture": "acc",			##2450[KK,?_?] C+2+3+S, AnotherRampFull, DetailBLineG, DetailRLineR, SE SEA SH	//[KK]
	"main_texture_studio": "main",	##[__,?_?] MainTex, Color, Patternuv1, Cutoff, CutoutClip, patternclamp1, patternrotator1
	#----------------
	"main_item_studio_add": "alpha",   ##3000[KK,?_?] t__Main \\ Color, Color2, Color3, alpha
	
	
	#### KKS
	"main_clothes_alpha": "alpha",
	"main_clothes_opaque": "cloth",
	"main_clothes_item": "item",
	"main_clothes_emblem": "color", #shader_dict["main_emblem"],
	"main_clothes_item_glasses": "glass",
	"main_item_ditherd": "color",
	 ## Color, overcolor1, overcolor2, overcolor3
	 #--- Nashi IBL Bunny
	"IBL_Shader_alpha": "color",
	"IBL_Shader_cutoff": "color",
	"IBL_Shader": "metal", ## Glossiness, Metallic, Occlusion
	"IBL_Shader_light_alpha" : "color", ## [Madevil] t__Detail, t__Main, t__NorMap, c__Color, c__RimColor, Glossiness, Metallic
	##
	"hair_main_sun_front": "hair", ##[hair] + Color2onoff, Color3onoff: flag to disable [Root] / [Tip]
	###
	"AIT/Item": "item", ## ALL OF THE TEXTURES, 15 colors for whatever reason, and like 30 parameters.
	## WAY TOO MANY OPTIONS
	"KKUTS": "skin",
	"KKUTShair": "hair",
	"KKUTSeyew": "item",
	"KKUTSitem": "item",
	"KKUSSitem": "item",
	"xukmi/MainAlphaPlusTess": "alpha", ## t__Alpha, t__Another, t__Detail, t__Emission, t__Line, t__Liquid, t__Main, t__NorMap, ...
	"xukmi/MainOpaquePlusTess": "cloth", ## t__Alpha, t__Another, t__Detail, t__Emission, t__Line, t__Liquid, t__Main, t__NorMap, ...
	"xukmi/MainOpaquePlus": "cloth", ## t__Alpha, t__Another, t__Detail, t__Emission, t__Line, t__Liquid, t__Main, t__NorMap, ...
	"xukmi/HairFrontPlus": "hair", 
	"xukmi/SkinPlus": "item", 
	"xukmi/MainItemAlphaPlus": "alpha", 
	"xukmi/MainItemPlus": "item",
	"xukmi/MainAlphaPlus": "alpha",
	"xukmi/HairPlus": "hair", 
	"xukmi/EyeWPlus": "color", ## t__Main, c__Color, c__Custom, c__Shadow, Cutoff, UseRampForLights
	
	"main_hair2": "hair2",
	"main_hair_front2": "hair2",
	}
#has_tex_map = {
#	"xukmi/MainAlphaPlusTess": [t__Alpha, t__Another, t__Detail, t__Emission, t__Line, t__Main, t__NorMap, t__NorMapDet],
#	"IBL_Shader": [t__Detail, t__Main, t__NorMap, t__overtex1, t__overtex2, t__overtex3], ## No transparent tex
#	"IBL_Shader_alpha": "IBL_Shader", ## Shader respects transparent tex
#	
#}

_extraAttributes = [
	"DisplaceFull",        ## 
	"DisplaceMultiplier",  ## 
	"ShrinkVal",           ## 
	"ShrinkVerticalAdjust" ## Y-Axis Adjustment
	]


## shorthands:  __typePrinter_Dict
if __name__ == '__main__': util.main_starter(parseMatComments)