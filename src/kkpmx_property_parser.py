# Cazoo - 2021-06-12
# This code is free to use and re-distribute, but I cannot be held responsible for damages that it may or may not cause.
#####################
from typing import List
import re
import os
import json
import copy   ## copy.deepcopy

import kkpmx_core as kklib
import kkpmx_utils as util

try:
	import nuthouse01_core as core
	import nuthouse01_pmx_parser as pmxlib
	import nuthouse01_pmx_struct as pmxstruct
	import _prune_unused_bones as bonelib
	import _translation_tools as tlTools
	import morph_scale
except ImportError as eee:
	print(eee.__class__.__name__, eee)
	print("ERROR: failed to import some of the necessary files, all my scripts must be together in the same folder!")
	print("...press ENTER to exit...")
	input()
	exit()
	core = pmxlib = pmxstruct = morph_scale = bonelib = None

#############
### :: (\w+)( +):= "_(\w+).png"   --> \1\2= "\3"
t__Alpha     = "AlphaMask"
t__Another   = "AnotherRamp"
t__Color     = "ColorMask"
t__Detail    = "DetailMask"
t__Glass     = "GlassRamp"
t__HairGloss = "HairGloss"
t__Line      = "LineMask"
t__Liquid    = "liquid"
t__Main      = "MainTex"
t__MainCol   = "MainC"
t__NorMap    = "NormalMap"
t__NorMapDet = "NormalMapDetail"
t__NorMask   = "NormalMask"
t__overtex1  = "overtex1"
t__overtex2  = "overtex2"
t__overtex3  = "overtex3"

Color_1 = "Color"
Color_2 = "Color2"
Color_3 = "Color3"
Color_Tex1 = "overcolor1"
Color_Tex2 = "overcolor2"
Color_Tex3 = "overcolor3"
Color_Line     = "LineColor"
Color_Shadow   = "ShadowColor"
Color_Specular = "SpecularColor"

##########
## meta attributes
NAME     = "name"
BASE     = "base"
OPTIONS  = "options"
#---
OPT_ENG  = "use_english"
OPT_HAIR = "process_hair"
#---
GROUP    = "group"    ### Determines the texture type to use. Will fallback to [shader] if missing.
TEXTURES = "textures" ### Maybe call it "used_textures"
INHERIT  = "inherit"  ### Shallow copy all attributes from the target block
META     = "meta"     ### Opens sub tree for meta attributes of the asset
TEMPLATE = "template" ### If true, the block will be considered used when determining unused blocks.
MODE     = "mode"     ### Secret option to override the "blend_mode" for DetailMask
#--- runtime only
IDX      = "index"
NO_FILES = "no_files"
PARENT   = "parentMat"
PARSED   = "parsed"
ROOT     = "root"
#---- added by plugin
SHADER     = "shader"
AVAILABLE  = "available"
MT_ENABLED = "enabled"
MT_RECEIVE = "receive"
MT_SHADOWS = "shadows"
MT_RENDER  = "render"
MT_PARENT  = "parent"
MT_SLOT    = "slot"
#---- Extras
ARGSTR    = "argStr"
t__Reuse  = "Reuse"

#############
helptext = """
This is the second of two main methods to make KK-Models look better.
- Note: Current/Working directory == same folder as the *.pmx file.
- Within the *.json file, this is abbreviated as "%PMX%".

It will parse a processed plugin file and apply colors and shaders, as well as combining textures.
It also sets the visibility on customized multi-part assets and adds the accessory slots into the comment.
-- Remarks: All texture adjustments work based on "Garbage in, Garbage out": The results are only as good as the sum of the sources.

This does require some preparations before it can be used:
[1] A *.json file generated by [(7) GenerateJsonFile]
-- Default looks for "#generateJSON.json" in the working directory
-- Otherwise asks for the path if not found
[2] A folder filled with extra textures exported from KK (requires the [MaterialEditor] mod)
-- The path will be read from the above *.json in "options" > "base" and defaults to "./extra".
-- Currently working / supported are:
-- -- MainTex (already exported by [PMXExport], so can be ignored)
-- -- DetailMask
-- -- ColorMask
-- -- LineMask
-- -- overtex1 (on body and eye)
-- -- overtex2 (on eye)
-- Not (yet) supported are:
-- -- on body: overtex2
-- -- on face: overtex1, overtex2, overtex3
-- -- NormalMap, NormalMask

Additional notes:
-- After generation, the *.json file can be edited to change some aspects (some colors, visibility, textures) without KK. Re-run this to apply changes.
-- Due to pre-generation, sometimes textures are used that do not exist (which will print a warning). Remove the item from the faulty material's template to clear the warning.

Options (for Automization):
- apply: bool -- True to not wait for results and write directly to model. Prompts if [None]

"""
DEBUG = util.DEBUG or False

## Todos: Root Path \\ Figure out how to apply fixes for ColorMask (Additive Merge)

#############

pathDetail = r'.\extra\#Apply_DetailMap.py'
pathColor  = r'.\extra\#Apply_ColorMap.py'
pathBOver1 = r'.\extra\#Apply_Body_overtex1.py'
pathOT_eye = r'.\extra\#Apply_overtex1__eyes.py'
pathLine   = r'.\extra\#Apply_LineMap.py'

suffix_Col   = "_pyCol"
suffix_Det   = "_pyDet"
suffix_Line  = "_pyLin"
suffix_HL    = "_pyHL"
suffix_OT1   = "_pyOT1"
suffix_OTEye = "_pyOTHL"
######
## State -- maybe change to { mat_name: state[of "miss", "no_action", "no_files", "ok" ]}
msgs = { 'miss': [], 'no_action': [], 'no_files': [] }
msgsPre = "-- "
global_state = { }
state_info = "showinfo"

################

def parseMatComments(pmx, input_file_name: str, write_model = True, moreinfo = False, opt = {}):
	paths = os.path.split(input_file_name)
	root = paths[0]
	print("==== Start Parsing ====")
	print("-- [Working Directory]: " + root);
	
	path = os.path.join(root, "#generateJSON.json") #@todo_note "<< Default file name >>"
	global_state[state_info] = moreinfo or DEBUG
	global_state[ARGSTR] = {}
	#### Load JSON
	def callback(raw_data):
		# replace Shorthand
		raw_data = raw_data.replace("%PMX%", re.escape(root)) #@todo_note "<< explain %PMX% >>"
		#raw_data = raw_data.replace("%PMX%", root.replace(r'\\', r'\\\\'))
		raw_data = raw_data.replace("SpeclarHeight", "SpecularHeight")
		raw_data = raw_data.replace("shadowcolor", Color_Shadow)
		return raw_data
	data = util.load_json_file(path, callback)
	if not data: return ## User already knows the reason
	
	__parse_json_file(pmx, data, root)
	
	### Trim all textures
	for (idx,tex) in enumerate(pmx.textures):
		if os.path.isabs(tex):
			pmx.textures[idx] = os.path.relpath(tex, root)
	
	if write_model:
		flag = opt.get("apply", None)
		if flag is None: flag = (core.MY_GENERAL_INPUT_FUNC(lambda x: x in ['y','n'], "Apply changes ?") == 'y')
		if flag:
			return kklib.end(pmx, input_file_name, "_props")
		return input_file_name
	else: return kklib.end(None, input_file_name, "_props")
parseMatComments.__doc__ = helptext


def __parse_json_file(pmx, data: dict, root: str):
	"""
	@param pmx [Pmx]
	@param data [dict] The parsed JSON object
	@param root [str] The root path of the pmx file
	"""
	verbose = global_state[state_info]
	##### == Processing JSON Dict
	attrDict = { }
	base = data.get(BASE, None) #@todo_note "BASE can be used to provide a relative base path for texture references"
	
	data.setdefault(OPTIONS, {})
	#options = defaults | data[OPTIONS] ## Python 3.9
	options = {
		BASE: base, # @todo_add "BASE can be defined alone or inside OPTIONS"
		OPT_ENG: False, #@todo_note: "Using OPT_ENG, the display name (name_jp) in the editor must not match the filename segment"
		OPT_HAIR: False,
	}
	options.update(data[OPTIONS])
	if base is None: base = options[BASE] #@todo_add "Outside BASE has priority over the one in OPTIONS"
	#--- NAME
	name = data.get(NAME, None)
	if name and pmx.header.name_jp in ["Koikatu","koikatu","Koikatsu","koikatsu","",None]:
		pmx.header.name_jp = name
		pmx.header.name_en = name
	
	ask_to_rename_extra(base)
	fix_material_names(pmx, data)
	hair_tabu = []
	global_state[OPT_HAIR] = {}
	
	
	for mat_name in data.keys():
		if mat_name in [NAME, BASE, OPTIONS]: continue
		mat_idx = util.find_mat(pmx, mat_name, False)
		if mat_idx == -1:
			if type(data[mat_name]) == dict:
				if data[mat_name].get("template",False): continue # @todo_note "if TEMPLATE is true, it does not count as 'no match'"
			msgs['miss'].append(msgsPre + mat_name)
			print("\nCould not find {}, skipping".format(mat_name)); continue
		mat = pmx.materials[mat_idx]
		attr = data[mat_name]
		if len(attr) == 0: continue ## Catches {},[],"" #@todo_add "<< silent ignore of empty elements >>"
		print("\n==== Processing " + mat.name_jp)
		# Copy Type
		if type(attr) in [str, list]:
			isStr = type(attr) == type("")
			org = attr if isStr else attr[0] ## [0] bc list
			if org not in data:
				print("Did not find '{}' to inherit attributes from".format(org))
				continue
			print("> Copy attributes from " + org)
			attr = data[org]
			if isStr: attr[NO_FILES] = True ## @todo_note "Inherit[A]: Reuse the files of [inherit]"
			elif NO_FILES in attr: del attr[NO_FILES] ## @todo_note "Inherit[B]: Reuse all but files"
			attr[PARENT] = org
		#if True:#PARSED not in attr:
		# Field: Inherit
		if INHERIT in attr: ## @todo_note "Inherit[C]: Extend [inherit] with own fields"
			org = attr[INHERIT]
			if org not in data:
				print("Did not find '{}' to inherit attributes from".format(org))
				continue
			if verbose: print("> Extends " + org)
			#attr = data[org] | attr ### New in py 3.9
			tmp = copy.deepcopy(data[org])
			tmp.update(attr)
			attr = tmp
		# Field: Render Type
		if GROUP not in attr:  #@todo_note "GROUP determines action"
			if SHADER in attr: #@todo_note "SHADER is fallback for GROUP"
				attr[GROUP] = shader_dict.get(attr[SHADER], attr[SHADER])
			else:
				print(f"Material has no '{GROUP}' attribute, using 'item' instead") #@todo_add[GROUP] "'item' is default for GROUP"
				attr[GROUP] = "item"
		# Field: Do not reprocess if cloning
		if TEXTURES in attr: #@todo_note "TEXTURES can be used to use default names based on KK & BASE"
			if base is None:
				print("[err] Cannot process default textures without base path") #@todo_add[BASE] "BASE is required when using TEXTURES"
				return
			base_mat = mat
			if NO_FILES in attr: base_mat = pmx.materials[util.find_mat(pmx, attr[PARENT])] #@todo_ref "<< Inherit[A] >>"
			name = base_mat.name_en if options[OPT_ENG] else base_mat.name_jp ## @todo_ref "<< OPT_ENG >>"
			name = re.sub(r"\*\d","",name) #@todo_note "<< smt about '* not allowed in filename' >>"
			for tex in attr[TEXTURES]:
				if tex not in texSuffix:
					print("[NotImpl] Could not find texture key '{}'".format(tex))
					continue
				if texDict[tex] in attr: continue ## @todo_add "All TEXTURES can be hardcoded with explicit paths (+ << %PMX% >>) and override defaults"
				## @todo_note: "if 'MainTex' is used but does not exist in BASE, use the one registered in the PmxMaterial, if any"
				attr[texDict[tex]] = os.path.join(base, name + texSuffix[tex])
				if tex == t__Main and base_mat.tex_idx > -1:
					if not os.path.exists(attr[texDict[tex]]):
						attr[texDict[tex]] = os.path.join(root, pmx.textures[base_mat.tex_idx])
		# Field: Add hair flag and keep track of duplicates
		if (attr[GROUP] == "hair"):
			attr[OPT_HAIR] = options[OPT_HAIR] and (attr[INHERIT] not in hair_tabu)
			hair_tabu.append(attr[INHERIT])
		
		#---
		if verbose: print(">--> Found {} attributes to process".format(len(attr)))
		attr[ROOT] = root
		attr[PARSED] = True
		parseDict = {
			'cloth': parse_acc, 'acc': parse_acc, 'item': parse_acc,
			'body': parse_body, 'face': parse_face,
			'eye': parse_eye, 'hair': parse_hair, 'color': parse_color,
			'alpha': parse_acc, 'ignore': parse_pass, 'glass': parse_glass,
			}
		if attr[GROUP] in parseDict: parseDict[attr[GROUP]](pmx, mat, attr); #exit()
		else:
			msgs['no_action'].append(msgsPre + mat.name_jp)
			parseDict["item"](pmx, mat, attr)#; exit()
	#######
	### Display summary for quick glance that something did not work
	arr = []
	## Remove meta items
	for a in [msgsPre + s for s in [NAME,BASE,OPTIONS]]:
		try:
			msgs['miss'].remove(a)
		except: pass
	
	if len(msgs['miss']) > 0:      arr.append('\n'.join(["The following elements were not found:", '\n'.join(msgs['miss'])]))
	if len(msgs['no_action']) > 0: arr.append('\n'.join(["The following materials had no valid action:", "\n".join(msgs['no_action'])]))
	if len(msgs['no_files']) > 0:
		tmp = [msgsPre + os.path.relpath(tex, base) for tex in msgs['no_files']]
		arr.append('\n'.join(["Additionally, these textures failed to generate:", "\n".join(tmp)]))
		arr.append("- To fix the above, provide the missing base file or remove it from the 'textures' element of the material")
	if len(arr) > 0:                    print('\n'.join(["==========",'\n\n'.join(arr),"=========="]))

#################
#### Parsers ####
#################
## name_jp: str, name_en: str,
## diffRGB: List[float],
## specRGB: List[float],
## ambRGB: List[float],
## alpha: float, specpower: float,
## edgeRGB: List[float], edgealpha: float, edgesize: float,
## tex_idx: int,
## sph_idx: int, sph_mode: int, --> Disabled, Add, Multi, Sub Texture
## toon_idx: int, toon_mode: int, --> 0 or 1
## comment: str,
## faces_ct: int,
## flaglist: List[bool], --> 2-SIDE, G-SHAD, S-MAP, S-SHAD, use_edge, V-COLOR, [Point], [Line]


def parse_color(pmx, mat, attr):
	print(":: Running 'color' parser")
	if Color_1 in attr:
		if mat.tex_idx != -1 and mat.diffRGB != [0,0,0]:
			mat.comment += "\r\n Old Diffuse: " + str(mat.diffRGB) + " (by parser)"
			mat.diffRGB = [0,0,0]
		mat.ambRGB = attr.get(Color_1, [0,0,0])[:3]
	#	mat.ambRGB = attr.get(Color_Shadow, attr[Color_1])[:3]
	#elif Color_Shadow in attr:
	#	mat.ambRGB = attr[Color_Shadow][:3]

def parse_body(pmx, mat, attr):
	print(":: Running 'body' parser")
	### (sic): body has no t__Alpha
	# t__Detail, t__Line, t__liquid, t__Main, t__NorMap, t__NorMapDet, t__NorMask, t__overtex1+2+3
	# Color_Tex1+2+3,  Color_Shadow, Color_Specular
	# DetailNormalMapScale, nip, nip_specular, nipsize, notusetexspecular
	# rimpower, rimV, ShadowExtend, SpeclarHeight, SpecularPower, SpecularPowerNail, tex1mask
	###
	extend_colors(attr, [Color_Tex1, Color_Tex2, Color_Tex3, Color_Shadow, Color_Specular])
	attr.setdefault(t__overtex1, None)
	attr.setdefault(t__overtex2, None)
	#attr[Color_Shadow] = None ## @todo_note:: "custom Shadows make skin look weird"
	#del attr[Color_Shadow]
	process_common_attrs(pmx, mat, attr)
	if t__Detail in attr: #pass ## Load file, pass to [detail python]
		process_color_and_detail(pmx, mat, attr)
	if t__Line in attr:
		handle_body_line(pmx, attr)
		set_new_texture(pmx, mat, attr, [get_working_texture(attr), suffix_Line + ".png"])
	#if attr[t__NorMap]: pass
	#if attr[t__NorMask]: pass
	#if attr[t__NorMasDet]: pass
	if attr[t__overtex1]:
		handle_body_overtex1(pmx, attr)
		set_new_texture(pmx, mat, attr, [get_working_texture(attr), suffix_OT1 + ".png"])
	if attr[t__overtex2]: pass ##handle_body_overtex1(pmx, attr)

def parse_face(pmx, mat, attr):
	print(":: Running 'face' parser")
	###
	# t__Alpha, t__Detail, t__Line, t__liquid, t__Main, t__NorMap, t__NorMapDet, t__NorMask, t__overtex1+2+3
	# Color_Tex1+2+3, Color_Shadow, Color_Specular
	# DetailNormalMapScale, nip, nip_specular, nipsize, notusetexspecular, tex1mask
	# rimpower, rimV, ShadowExtend, SpeclarHeight, SpecularPower, SpecularPowerNail
	###
	extend_colors(attr, [Color_Tex1, Color_Tex2, Color_Tex3, Color_Shadow, Color_Specular])
	process_common_attrs(pmx, mat, attr)
	## [t__Line] ++ DetailNormalMapScale :: [SpecialEffects]
	#>> RGB-B ++ Alpha (0-200)
	if t__Detail in attr: #pass ## Load file, pass to [detail python]
		process_color_and_detail(pmx, mat, attr)
	if t__Line in attr:
		handle_body_line(pmx, attr)
		set_new_texture(pmx, mat, attr, [get_working_texture(attr), suffix_Line + ".png"])
	#if attr[t__NorMap]: pass
	#if attr[t__NorMask]: pass
	#if attr[t__NorMasDet]: pass
	#if attr[t__overtex1]:
	#	handle_body_overtex1(pmx, attr)
	#	set_new_texture(pmx, mat, attr, [get_working_texture(attr), suffix_OT1 + ".png"])
	#if attr[t__overtex2]: pass ##handle_body_overtex1(pmx, attr)
########
	pass

def parse_acc(pmx, mat, attr):
	print(":: Running 'acc' parser")
	###
	# t__Another, t__Color, t__Detail, t__Line, t__Main, t__NorMap
	# Color_1, Color_2, Color_3, Color_Shadow
	# rimpower, rimV, ShadowExtend, SpeclarHeight
	###
	extend_colors(attr, [Color_1, Color_2, Color_3, Color_Shadow, Color_Specular])
	process_common_attrs(pmx, mat, attr)
	process_color_and_detail(pmx, mat, attr)
	if t__Line in attr: process_line_mask(pmx, mat, attr)

def parse_eye(pmx, mat, attr): ## @open: rotation, offset, scale
	print(":: Running 'eye' parser")
	####
	## t__expression, t__Main, t__overtex1, t__overtex2
	## Color_Tex1+2, Color_Shadow, exppower, isHighLight, rotation
	####
	extend_colors(attr, [Color_Tex1, Color_Tex2, Color_Shadow], True)
	if t__overtex1 in attr or t__overtex2 in attr:
		handle_eye_highlight(pmx, attr)
		set_new_texture(pmx, mat, attr, [attr[t__Main], suffix_HL + ".png"])

def parse_hair(pmx, mat, attr): ## @open: t__Color, t__Detail, t__HairGloss, Color2, Color3
	print(":: Running 'hair' parser")
	###
	# t__Alpha, t__Another, t__Color, t__Detail, t__HairGloss, t__Main, t__NorMap
	# Color_1, Color_2, Color_3, Color_Line, Color_Shadow
	# rimpower, rimV, ShadowExtend, SpeclarHeight
	###
	extend_colors(attr, [Color_1, Color_2, Color_3, Color_Line, Color_Shadow])
	process_common_attrs(pmx, mat, attr)
	if attr[OPT_HAIR]: process_color_and_detail(pmx, mat, attr)
	elif attr[INHERIT] in global_state[OPT_HAIR]:
		attr[t__Reuse] = global_state[OPT_HAIR][attr[INHERIT]]
		print(f"> Reusing texture {attr[t__Reuse]}")
		set_new_texture(pmx, mat, attr, [attr[t__Reuse], ".png"])
		
	if Color_1 in attr: mat.diffRGB = attr[Color_1][:3]

def parse_alpha(pmx, mat, attr): ## @todo
	print(":: Running 'alpha' parser")
	###
	# t__Alpha, t__Another, t__Color, t__Detail, t__Main, t__NorMap
	# Color_1, Color_2, Color_3, Color_Line, Color_Shadow
	# rimpower, rimV, ShadowExtend, SpeclarHeight
	###
	extend_colors(attr, [Color_1, Color_2, Color_3, Color_Line, Color_Shadow])
	process_common_attrs(pmx, mat, attr)
	process_color_and_detail(pmx, mat, attr)
	if Color_1 in attr: mat.diffRGB = attr[Color_1][:3]

def parse_glass(pmx, mat, attr):
	mat.specpower = 1.0
	parse_color(pmx, mat, attr)

def parse_pass(pmx, mat, attr): pass
####################
#### Processing ####
####################

def script__draw_toon_shader(args):
	import numpy as np
	import cv2
	### https://github.com/jerryhouuu/Draw-Gradient-Alpha-Rectangle-using-openCV
	def draw_gradient_alpha_rectangle(frame, BGR_Channel, rect_pos=None, rotate=None):
		"""
		frame: The image to draw in :: np.zeros((300, 300, 3), np.uint8) ++ [:,:,:] = 255
		BGR_Channel: The target color, as tuple(B, G, R) ##(R, G, B) ?
		rect_pos: The area to draw a gradient into.
		rotate (white to color): 0 (L-R), 1(Upwards), 2(R-L), 3(Downwards)
		"""
		if rect_pos is None: rect_pos = ((0,0), (frame.shape[0], frame.shape[1]))
		if rotate is None: rotate = 3
		(xMin, yMin), (xMax, yMax) = rect_pos
		color = np.array(BGR_Channel, np.uint8)[np.newaxis, :]
		mask1 = np.rot90(np.repeat(np.tile(np.linspace(1, 0, (rect_pos[1][1]-rect_pos[0][1])), ((rect_pos[1][0]-rect_pos[0][0]), 1))[:, :, np.newaxis], 3, axis=2), rotate) 
		frame[yMin:yMax, xMin:xMax, :] = mask1 * frame[yMin:yMax, xMin:xMax, :] + (1-mask1) * color
		return frame#42, 175, 121
	frame = np.zeros((64, 64, 3), np.uint8)
	## options
	BGR = True
	gradient = 0
	####
	if BGR: color = list(reversed(args[1]))
	else: args[1]
	if gradient == 0: frame[:,:,:] = 255
	else:
		frame[:,:,0] = color[0]
		frame[:,:,1] = color[1]
		frame[:,:,2] = color[2]
		def adjust(c,i): c[i]= min(c[i] * 0.75,255)
		adjust(color,0); adjust(color,1); adjust(color,2)
	if gradient == 2: ### [:,32,*] = vertical
		frame[32:,:,0] = color[0]
		frame[32:,:,1] = color[1]
		frame[32:,:,2] = color[2]
		#frame[:2,:,:] = 255
	else: frame = draw_gradient_alpha_rectangle(frame, tuple(color), ((0,32), (64,64)))
	cv2.imwrite(args[2], frame)

def add_toon_shader(pmx, mat, attr):
	color = tuple(attr[Color_Shadow][:3])
	root = attr[ROOT]
	rgb = (int(color[0]*255), int(color[1]*255), int(color[2]*255))
	name = f"toon__{rgb[0]}_{rgb[1]}_{rgb[2]}.png"
	pathDir = os.path.join(root, "toon")
	pathFile = os.path.join(pathDir, name)
	if not os.path.exists(pathFile):
		if not os.path.exists(pathDir): os.mkdir(pathDir)
		args = ["", rgb, pathFile]
		script__draw_toon_shader(args)
	set_new_texture(pmx, mat, attr, [pathFile], tex_mode_toon)

def process_common_attrs(pmx, mat, attr): ## @open: rimpower, rimV, Color_Shadow
	###
	# Color_Line, Color_Shadow, Color_Specular (figure out smt new)
	# Set: specRGB, specpower, ambRGB, edgesize, edgeRGB, edgealpha, alpha, flaglist
	###
	if Color_Line in attr:
		if attr[Color_Line] == [0,0,0,0]:
			mat.flaglist[4] = False
			mat.edgesize = 0
		mat.edgeRGB = attr[Color_Line][:3]
		mat.edgealpha = attr[Color_Line][3]
	#if Color_Specular in attr:  mat.specRGB   = attr[Color_Specular][:3] :: Individual per group
	if "SpecularPower" in attr: mat.specpower = attr["SpecularPower"]
	if "LineWidthS" in attr:    mat.edgesize  = attr["LineWidthS"]
	if Color_Shadow in attr:# and attr[GROUP] not in ["hair"]:
		# smt smt only if bnot already set
		#if mat.ambRGB == [1,1,1]: mat.ambRGB    = attr[Color_Shadow][:3]
		#mat.diffRGB   = attr[Color_Shadow][:3]
		if mat.diffRGB == [1,1,1]:
			mat.diffRGB = [0.5, 0.5, 0.5]
			#mat.diffRGB   = [0,0,0]#attr[Color_Shadow][:3] smt only for black types
		add_toon_shader(pmx, mat, attr)
	#	mat.comment += "Make toon_shader: " + str(attr[Color_Shadow]) ## Multiply each by 255 before
	if META in attr:
		meta = attr[META]
		#### Shadows
		## "On": == "one-sided", but 2-SIDE is default in PMX for all objects
		## "Two-sided": Makes single-sided objects two-sided
		## Maybe add "one-sided" instead #@todo:: find a reliable fix for that, or add a note
		shadow  = meta.get(MT_SHADOWS, "On")
		if shadow == "Shadows Only":
			mat.flaglist[4] = False #[use_edge]
			mat.flaglist[5] = True  #[V-COLOR]
		elif shadow == "Off": # no 2-side, G-SHAD, S-MAP, S-SHAD
			fl = mat.flaglist
			mat.flaglist = [ False, False, False, False, fl[4], fl[5], fl[6], fl[7] ]
		mat.flaglist[3] = 1 if meta.get(MT_RECEIVE, False) else 0
		#### If not enabled, make 100% transparent + remove edge
		if not meta.get(MT_ENABLED, False):
			mat.alpha = 0
			mat.flaglist[4] = False
		#### Add Slot into Comment
		if MT_SLOT in meta:
			comment = meta[MT_SLOT]
			if comment in ["BodyTop","p_cf_head_bone"]: comment = meta[MT_PARENT]
			comment = "[:Slot:] " + comment
			par = meta[MT_PARENT]
			if re.match("ca_slot\d+", par):
				comment += "\r\n[:AccId:] " + re.match("ca_slot(\d+)", par)[1]
			if not mat.comment or len(mat.comment) == 0:
				mat.comment = comment
			else: mat.comment += "\r\n" + comment

def process_color_and_detail(pmx, mat, attr):
	def replFN(elem, name): return os.path.join(os.path.split(elem)[0], name)
	def getFN(elem): return os.path.splitext(os.path.split(elem)[1])[0]
	if t__Color in attr:
		attr.setdefault(t__Main, None)
		if attr[t__Main] and not os.path.exists(attr[t__Main]): attr[t__Main] = None
		## Check if there is no MainTex
		noMain = attr[t__Main] in [None,""] and META in attr
		if noMain:
			ff = getFN(attr[t__Color])
			if (ff.startswith("mf_m_primmaterial")):
				attr[t__Color] = replFN(attr[t__Color], "mf_m_primmaterial_ColorMask.png")
			attr["altName"] = re.sub("_ColorMask","",ff) + "@" + attr[META][MT_PARENT]
		else:
			### Ignore mf_m_primmaterial if they have a MainTex
			if (getFN(attr[t__Main]).startswith("mf_m_primmaterial")): return
		handle_acc_color(pmx, attr)
		ff = attr[t__Color if attr[t__Main] is None else t__Main]
		if noMain: ff = replFN(attr[t__Color], attr["altName"])
		attr[t__MainCol] = os.path.splitext(ff)[0] + suffix_Col + ".png"
	if t__Detail in attr:
		handle_acc_detail(pmx, attr)
		#if Color_Specular not in attr:
		#	mat.specRGB = mat.dif
	########
	if t__Reuse in attr:
		print(f"> Reusing texture {attr[t__Reuse]}")
		set_new_texture(pmx, mat, attr, [attr[t__Reuse], ".png"])
	# if no t__Main, but used t__Color and t__Detail
	elif t__MainCol in attr: ## @todo_note
		saved = False
		if t__Detail in attr:
			saved = set_new_texture(pmx, mat, attr, [ff, suffix_Col + suffix_Det + ".png"])
		if (not saved) or (t__Detail not in attr):
			set_new_texture(pmx, mat, attr, [ff, suffix_Col + ".png"])
	elif t__Detail in attr:
		set_new_texture(pmx, mat, attr, [attr[t__Main], suffix_Det + ".png"])
	if attr.get(OPT_HAIR, False):
		global_state[OPT_HAIR][attr[INHERIT]] = get_working_texture(attr)

def process_line_mask(pmx, mat, attr): handle_body_line(pmx, mat, attr)#pass

##############
#### Body ####
##############

def handle_body_detail(pmx, attr): ## @todo
	#attr[DetailMap_Scale] ## Mainly affects [Green]
	XXXX = attr["DetailNormalMapScale"] ## Render on top of ["nip"]
	XXXX = attr["notusetexspecular"]    ## Render on top of ["nip"]
	XXXX = attr["rimpower"]             ## 100% reduce "rimV" to Line
	XXXX = attr["rimV"]                 ## 0..100% of Specularity / Metal t__NorMask on Texture
	XXXX = attr["shadowExtend"]         ## Render on top of ["nip"]
	XXXX = attr["SpecularPower"]        ## Render on top of ["nip"]
	XXXX = attr["SpecularPowerNail"]    ## Render on top of ["nip"]
	XXXX = attr[Color_Specular]         ## 

def handle_body_overtex1(pmx, attr):
	#main = get_working_texture(attr)
	#mask = attr[t__overtex1]
	#col  = attr[Color_Tex1]
	#XXXX = attr["nip"]          # 1
	#spec = attr["nip_specular"] # 0.5 -- Strength of Layer X
	#size = attr["nipsize"]      # 0.6677417
	#mask = attr["tex1mask"]     # 1 -- Original vs. color overlay
	#-----------
	if NotFound(attr, t__overtex1): return
	
	arg1 = quote(get_working_texture(attr))
	arg2 = quote(attr[t__overtex1])
	js = { "color": attr[Color_Tex1], "nip":   attr["nip"], "size":  attr["nipsize"], "spec":  attr["nip_specular"] }
	js[state_info] = global_state[state_info]
	arg3 = quoteJson(js)
	call_img_scripts((pathBOver1, arg1, arg2, arg3), "body1", [3])

def handle_body_overtex2(pmx, attr): pass # @todo

def handle_body_line(pmx, attr):
	####
	# linetexon -- [Flag]: "body".t__Line.Green
	if NO_FILES in attr: return
	if NotFound(attr, t__Line): return
	arg1 = quote(get_working_texture(attr))
	arg2 = quote(attr[t__Line])
	js = { }
	js["mode"] = "overlay"
	js["linetexon"] = attr.get("linetexon",1) < 0  ## "body".tex__Line.Green
	js[state_info] = global_state[state_info]
	arg3 = quoteJson(js)
	call_img_scripts((pathLine, arg1, arg2, arg3), "line", [3])

##############
#### Face ####
##############

def handle_face_detail(pmx, attr): pass ## @todo

def handle_face_effects(pmx, attr): ## @todo
	if NO_FILES in attr: return
	alpha = float(attr.get("DetailNormalMapScale", 1.0))
	alpha *= float(attr.get("ShadowExtend", 1.0))
	## apply [t__Line.Blue] * alpha onto [t__Main]
	
	pass

def handle_eye_highlight(pmx, attr): ## Actually uses all three colors, so color in like body.overtex1
	if NO_FILES in attr: return
	arg1 = quote(attr[t__Main])
	js = { "highlight": attr["isHighLight"] }
	js["offset"] = attr.get("offset", "(0, 0)")
	js["scale"] = attr.get("scale", "(1, 1)")
	js[state_info] = global_state[state_info]
	arg2 = quoteJson(js)
	#### offset(\d, \d), scale(\d,\d) overcolor1, overcolor2
	if t__overtex1 in attr:
		arg3 = quote(attr[t__overtex1])
		col = (attr[Color_Tex1] * 255)
		js = { "color": col[:3], "alpha": col[3] }
		arg4 = quoteJson(js)
	else: arg3,arg4 = "","0"
	if t__overtex2 in attr:
		arg5 = quote(attr[t__overtex2])
		col = (attr[Color_Tex2] * 255)
		js = { "color": col[:3], "alpha": col[3] }
		arg6 = quoteJson(js)
	else: arg5,arg6 = "","0"
	call_img_scripts((pathOT_eye, arg1, arg2, arg3, arg4, arg5, arg6), "OT_eye", [2,4,6])

def handle_face_overtex2(pmx, attr): pass ## Do not merge, but try to add as extra ... material.... ._.

##############
#### Hair ####
##############

##############
#### Accs ####
##############

def handle_acc_color(pmx, attr):
	if NO_FILES in attr: return
	if NotFound(attr, t__Color): return
	
	main = attr.get(t__Main, None)
	if main and not os.path.exists(main): main = None
	attr[t__Main] = main
	attr.setdefault(Color_2, [0,0,0,1])
	attr.setdefault(Color_3, None)
	arg1 = '""' if attr[t__Main] == None else quote(attr[t__Main])
	arg2 = quote(attr[t__Color])
	arg3 = quoteColor(attr[Color_1])
	arg4 = quoteColor(attr[Color_2])
	arg5 = '"[]"' if attr[Color_3] == None else quoteColor(attr[Color_3])
	
	data = {"mode": "Additive", "altName" : attr.get("altName","")}
	if attr[GROUP] == "hair": data["hair"] = True
	data[state_info] = global_state[state_info]
	arg6 = quoteJson(data)
	
	argStr = "color"+arg1+arg2+arg3+arg4+arg5
	attr[ARGSTR] = argStr
	tmp = global_state[ARGSTR].get(argStr, None)
	if (tmp): attr[t__Reuse] = tmp
	else: call_img_scripts((pathColor, arg1, arg2, arg3, arg4, arg5, arg6), "color", [6])

def handle_acc_detail(pmx, attr): ## Has @todo_add \\ @open: All the props affecting t__Detail
	if NO_FILES in attr: return
	if t__Reuse in attr: return
	if NotFound(attr, t__Detail): return
	
	### Determine main texture & blend mode
	attr.setdefault(t__Main, None)
	mode = "overlay"
	if t__MainCol in attr:
		mode = "darken" ## Try: "mul" "diff" "nor"
		main = attr[t__MainCol]
	elif attr[GROUP] == 'cloth':
		mode = "darken"
		main = attr[t__Main]
	else: main = attr[t__Main]
	if MODE in attr: mode = attr[MODE]
	####
	if not os.path.exists(main):
		print(f">--> [MissingFile(Detail)]: {main}")
		return
	args = {}
	arg1 = quote(main)
	arg2 = quote(attr[t__Detail])
	arg3 = quote(global_state[state_info])
	arg4 = quote(attr[t__Main] is None)
	arg5 = quote(mode)
	arg6 = quote(attr[SHADER] == "body")
	if ARGSTR not in attr:
		argStr = "detail"+arg1+arg2+arg4+arg5
		attr[ARGSTR] = argStr
		tmp = global_state[ARGSTR].get(argStr, None)
		if (tmp): attr[t__Reuse] = tmp; return
	call_img_scripts((pathDetail, arg1, arg2, arg3, arg4, arg5, arg6), "detail")

############
#	X = attr[t__liquid]        ###	X = attr[t__Texture2]      ###	X = attr[t__Texture3]      ###	X = attr[Color_Liquid]     ##

#################
#### Utility ####
#################

def call_img_scripts(args, target, isJson = []):
	if DEBUG: os.system(' '.join(args))
	else:
		from unittest.mock import patch
		import runpy, sys
		try:
			target_dict = { 
				"color": "extra.#Apply_ColorMap",
				"detail": "extra.#Apply_DetailMap",
				"body1": "extra.#Apply_Body_overtex1",
				"OT_eye": "extra.#Apply_overtex1__eyes",
				"line": "extra.#Apply_LineMap",
			}
			if not target_dict.get(target): return
			with patch.object(sys, 'argv', [x.strip('"') for x in args]):
				runpy.run_module(target_dict.get(target))
		except Exception as eee: print(eee)

def ask_to_rename_extra(base):
	if not os.path.exists(base):
		print(f"{base} does not exist")
		return
	files = os.listdir(base)
	if not any(filter(lambda x: x.startswith("_Export"), files)): return
	if not util.ask_yes_no(f"Rename textures in [{base}]"): return
	re_cut = re.compile(r" ?\(Instance\)_?(\([-0-9]*\))?|_Export_[\d\-]+_")
	for fname in files:
		basename = os.path.join(base,fname)
		if not os.path.isfile(basename): continue
		newname = os.path.join(base, re_cut.sub("", fname))
		if basename == newname: continue
		if os.path.exists(newname):
			print(f"-- {os.path.relpath(newname, base)} already exists!")
			continue
		os.renames(basename, newname)

def fix_material_names(pmx, data):
	matJsn = []
	for mat_name in data.keys():
		if mat_name in [NAME, BASE, OPTIONS]: continue
		if re.search("(@ca_slot\d+|#-\d+)$", mat_name): continue
		matJsn.append(mat_name)
	matSkip = ["Bonelyfans", "c_m_shadowcast", "cf_m_tooth", "cf_m_noseline"]
	for mat in pmx.materials:
		name = re.sub("(@ca_slot\d+|#-\d+|\*\d+)?$", "", mat.name_jp)
		arr = [x for x in matJsn if x.startswith(name)]
		if len(arr) == 0:
			if any([x for x in matSkip if name.startswith(x)]): continue
			print(f"[*] {name} has no match in matJsn"); continue
		elem = arr[0]
		mat.name_jp = elem
		mat.name_en = elem
		del matJsn[matJsn.index(elem)]
	if len(matJsn) != 0: print("[**] matJsn is not empty: "); print(matJsn)
	
##############
	pass


#def quote(value): return '"' + re.sub("\\", "\\\\", str(value)) + '"'
def quote(value): ## return '"' + str(value).strip('"').strip("'") + '"'
	tmp =  '"' + str(value).strip('"').strip("'") + '"'
	return tmp
def quoteColor(value):
	tmp = []
	for (i,c) in enumerate(value): tmp.append(int(c*255))
	return '"' + str(tmp).strip('"').strip("'") + '"'
def quoteJson(value):
	tmp = json.dumps(value)
	if global_state.get(state_info, True): tmp = re.sub(r'"', r'\\"', tmp)
	return '"' + tmp + '"'

def extend_colors(attr, col_arr, dodefault = False):
	for col in col_arr:
		if col in attr:
			if dodefault: attr[col] = attr.get(col, [0,0,0])
			if attr[col] is None:   continue
			if len(attr[col]) < 3:  raise Exception("Warning: {} is too short!".format(col))
			if len(attr[col]) == 3: attr[col].append(1)

tex_mode_toon = "toon"
tex_mode_main = "main"
tex_mode_sphr = "sphere"
def set_new_texture(pmx, mat, attr, tex_names: list, tex_mode=tex_mode_main):
	"""
	:param  mat [PmxMaterial]  
	:param  attr [Dict]        
	:param  tex_names [Dict]   
	:param  tex_mode [enum]    "toon", "main", or "sphere"
	"""
	isToonMode = tex_mode == tex_mode_toon
	isSphereMode = tex_mode == tex_mode_sphr
	# [attr]: So that one can use "get_working_texture" but must not
	if tex_mode != tex_mode_main: tex_name = tex_names[0]
	else:  tex_name = os.path.splitext(tex_names[0])[0] + tex_names[1]
	if not os.path.exists(tex_name):
		msgs["no_files"].append(tex_name)
		return False
	if tex_name in pmx.textures:
		tex_idx = pmx.textures.index(tex_name)
	else:
		tex_idx = len(pmx.textures)
		pmx.textures.append(tex_name)
	if isToonMode:
		mat.toon_idx = tex_idx
		mat.toon_mode = 0
	elif isSphereMode:
		mat.sph_idx = tex_idx
		mat.sph_mode = 1
	else:
		mat.tex_idx = tex_idx
		attr[t__MainCol] = tex_name
		if ARGSTR in attr:
			tmp = attr[ARGSTR]
			if tmp not in global_state[ARGSTR]: global_state[ARGSTR][tmp] = tex_name
	return True

def get_working_texture(attr):
	if t__MainCol in attr:
		if attr[t__MainCol] is not None:
			return attr[t__MainCol]
	if t__Main in attr:
		if attr[t__Main] is not None:
			return attr[t__Main]
	raise Exception("Could not find working main texture")

def NotFound(attr, name, optional=False): ## Returns true if not found
	if name not in attr: return True
	if not os.path.exists(attr[name]):
		if optional: return True
		print(f">--> [MissingFile({name})]: {attr[name]}")
		return True
	return False

##############
## Mappings ##
##############
texDict = {
	"t__Alpha"     : "AlphaMask",
	"t__Another"   : "AnotherRamp",
	"t__Color"     : "ColorMask",
	"t__Detail"    : "DetailMask",
	"t__Glass"     : "GlassRamp",
	"t__HairGloss" : "HairGloss",
	"t__Line"      : "LineMask",
	"t__Liquid"    : "liquid",
	"t__Main"      : "MainTex",
	"t__NorMap"    : "NormalMap",
	"t__NorMapDet" : "NormalMapDetail",
	"t__NorMask"   : "NormalMask",
	"t__Overtex1"  : "overtex1",
	"t__overtex1"  : "overtex1",
	"t__Overtex2"  : "overtex2",
	"t__overtex2"  : "overtex2",
	"t__Overtex3"  : "overtex3",
	"t__overtex3"  : "overtex3",
}

texSuffix = { ### :: (\w+)( +):= ("_(\w+).png") --> '    "\1":\2\3,'
    "t__Alpha":     "_AlphaMask.png",
    "t__Another":   "_AnotherRamp.png",
    "t__Color":     "_ColorMask.png",
    "t__Detail":    "_DetailMask.png",
    "t__Glass":     "_GlassRamp.png",
    "t__HairGloss": "_HairGloss.png",
    "t__Line":      "_LineMask.png",
    "t__Main":      "_MainTex.png",
    "t__NorMap":    "_NormalMap.png",
    "t__NorMapDet": "_NormalMapDetail.png",
    "t__NorMask":   "_NormalMask.png",
    "t__Overtex1":  "_overtex1.png",
    "t__overtex1":  "_overtex1.png",
    "t__Overtex2":  "_overtex2.png",
    "t__Overtex3":  "_overtex3.png",
}
for (k,v) in copy.deepcopy(texDict).items():
	texDict[v] = texDict[k]
	if k in texSuffix:
		texSuffix[v] = texSuffix[k]

shader_dict = {
	### Ignore
	"toon_textureanimation": "ignore", ## gageye
	"shadowcast": "ignore",
	"Bonelyfans": "ignore",
	"mnpb": "ignore",          ## cf_m_mnpb
	# t__Glass, t__Main, t__NorMap ++ Color, Color4, *Sort,*Inverse,RimPower
	"toon_glasses_lod0": "glass", ## cf_m_namida_00, c_m_gomu
	### Small
	"toon_eyew_lod0": "color", ## t__Main ++ Color, shadowcolor \\ mayuge, sirome
	"toon_eye_lod0": "eye",    ## t__Main, t__expression, t__overtex1, t__overtex2 ++ **
	"toon_nose_lod0": "color", ## t__Main ++ Color
	"main_emblem": "color",    ## t__Main ++ shadowcolor
	#########
	## "main_skin": --> "face","body" are special case
	#	"main_skin": "body", ## cm_m_dankon, cm_m_dan_f
	# t__Another, t__Color, t__Detail, t__Line, t__Main, t__NorMap
	"main_item": "item",          ## AnotherRampFull, DetailBLineG, DetailRLineR, LineWidthS, ...
	"main_item_studio": "item",   ## ++ PatternMask 1,2,3 \\ several uncommon attr
	"main_item_emission": "item", ##  ++ z__AnimationMask \\ z__EmissionPower
	# t__Alpha, t__Another, t__Detail, t__Line, t__liquid, t__Main, t__NorMap, 
	"main_opaque": "cloth",
	"main_opaque2": "cloth", #-- z__AlphaMaskuv
	# t__Alpha, t__Another, t__Color, t__Detail, t__HairGloss, t__Main, t__NorMap
	"main_hair": "hair",
	"main_hair_front": "hair",
	"main_alpha": "alpha",
	# t__Color, t__Detail, t__Line, t__Main, t__NorMap
	"main_texture": "acc",  ## C+2+3+S, AnotherRampFull, DetailBLineG+RR, ShadowExtend(Another), SpeclarHeight
	#### 
	}


## shorthands:  __typePrinter_Dict
if __name__ == '__main__': util.main_starter(parseMatComments)